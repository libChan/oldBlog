<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="5个SOLID设计原则和GRASP"><meta name="keywords" content="Java"><meta name="author" content="Chan,undefined"><meta name="copyright" content="Chan"><title>5个SOLID设计原则和GRASP | Chan</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/reveal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/css/theme/black.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/css/zenburn.min.css"></head><body><div class="reveal"><div class="slides"><section data-markdown data-separator="---" data-separator-vertical="--" data-charset="utf-8"><script type="text/template">面向健壮性编程的设计原则
<!--more-->
 
- **SRP** 	The Single Responsibility Principle  	      单一责任原则
- 	 **OCP**        The Open-Closed Principle			      开放-封闭原则
- **LSP**         The Liskov Substitution Principle             Liskov替换原则
- **DIP**         The Dependency Inversion Principle       依赖转置原则
- **ISP**          The Interface Segregation Principle         接口聚合原则


## SRP（单一责任原则）
需要修改某个类的时候原因有且只有一个。
换句话说就是让一个类只承担一种类型责任，那么当这个类需要承当其他类型的责任的时候，就需要分解这个类。
> 一个类，一个责任。

这是一个违反了SRP的例子：

![](https://i.imgur.com/xIWG8Y7.jpg)


## OCP（开放封闭原则）

**对扩展开放，对修改封闭**

如何实现？抽象！为服务器端的代码（类型）抽象出一个抽象基类。
![](https://i.imgur.com/8fjj0f7.jpg)

通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对**修改的封闭**。
当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对**扩展的开放**。

感觉OCP和Decorator的思想很相似，面临新的变化时，在原有的基础上独立出另一个功能。

## LSP（ Liskov替换原则）

子类型必须能够替换父类型。

## ISP（接口分离原则）

客户端不应该被迫依赖于它们不用的接口。**一个接口或者类应该拥有尽可能少的行为**。

包含了无用方法的"胖接口"会增加类之间的耦合，可以分解为很多小接口。

## DIP（依赖倒置原则）

**高层模块不应该依赖底层模块，两者都应该依赖其抽象**

为什么细节类不应该彼此紧耦合，而要依赖于抽象？强耦合会导致代码面临新的变化时修改困难，难以扩展。

发现这一篇博客里的例子将这个想法讲得非常到位：[依赖倒置原则](https://blog.csdn.net/hfreeman2008/article/details/52289571)



## GRASP

General Responsibility Assignment Software Patterns **通用职责分配软件模式**

**怎样设计类，分配它们的行为职责，以及明确类之间的相互关系等**









</script></section></div></div><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/lib/js/head.min.js"></script><script src="https://cdn.jsdelivr.net/npm/reveal.js@3.6.0/js/reveal.min.js"></script><script>Reveal.initialize({
  mouseWheel: false,
  transition: 'slide',
  transitionSpeed: 'default',
  parallaxBackgroundImage: '',
  parallaxBackgroundSize: '',
  parallaxBackgroundHorizontal: '',
  parallaxBackgroundVertical: '',
  markdown: {
    smartypants: true
  },
  dependencies: [
    { src: '/js/third-party/reveal/marked.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: '/js/third-party/reveal/markdown.min.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    // Syntax highlight for <code> elements
    { src: '/js/third-party/reveal/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    // Zoom in and out with Alt+click
    { src: '/js/third-party/reveal/zoom.min.js', async: true },
    // Speaker notes
    { src: '/js/third-party/reveal/notes.min.js', async: true },
    // MathJax
    { src: '/js/third-party/reveal/math.min.js', async: true }
  ]
});</script></body></html>