<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记几个Lab过程中的bug]]></title>
    <url>%2F2018%2F06%2F03%2F%E8%AE%B0%E5%87%A0%E4%B8%AALab%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[写在前面Lab3-Lab5终于告一段落，持续了很久的实验，Lab3完成了程序的功能，Lab4补充功能并完成健壮性检查，Lab5主要进行I/O策略的优化，并分析程序运行情况。从实践学习Java的过程，会踩一些没有经验的坑，也是提升Java编程水平的过程。仅仅记录几个这个阶段的我学习过程中的bug，Java初学者，不正确的地方望指正。 1. 类内实例化自身具体怎么萌生这个神奇的想法我也无从考据了T_T……我只知道后来一直在为自己曾经的脑洞买单T_T 看一看这个bug： 123public class GraphPoet extends ConcreteGraph &#123; private GraphPoet graph = new GraphPoet();&#125; 这么搞的下场是Stack overflow，冷静分析一下，当一个类存储在栈上，相应的存储他的成员，但存储成员时，又实例化了一个新的“自己”，如此反复，栈空间耗尽，车祸现场。 debug！ 123public class GraphPoet extends ConcreteGraph &#123; private static GraphPoet graph = new GraphPoet();&#125; 对于当时的实验情况，加上关键字static就解决了栈溢出的问题，static是全局变量，当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例共用同一个static变量。所以在类的初始化时就创建了graph，实例化时则不再重复创建。 上述写法其实是不成熟的，当时对概念不够理解。后来发现对“静态变量“的使用是有所考究的，以下场景可以考虑使用静态变量： 变量所包含的对象体积较大，占用内存较多。 变量所包含的对象生命周期较长。 变量所包含的对象数据稳定。 该类的对象实例有对该变量所包含的对象的共享需求。 2.单例模式为什么说之前的代码是不成熟的，创建了一个static全局变量，全局变量可以直接通过类名调用，然而我却加上了private，Lab5思考到这个问题后，发现单例模式可以很好的应用在我的程序，满足需求，节省程序空间。 12345678public class GraphPoet extends ConcreteGraph &#123; private static final GraphPoet graph = new GraphPoet(); private GraphPoet() &#123;&#125; public static GraphPoet getInstance() &#123; return graph; &#125; 3.Junit的测试顺序Junit的测试函数的执行顺序是不确定的，符合单元测试的思想。 Junit 4.11里增加了指定测试方法执行顺序的特性 测试类的执行顺序可通过对测试类添加注解 “@FixMethodOrder(value)” 来指定,其中value 为执行顺序 三种执行顺序：默认MethodSorters.DEFAULT，按方法名MethodSorters.NAME_ASCENDING，按JVM返回的顺序MethodSorters.JVM. 当没有指定任何顺序时，按默认来执行 ，多次执行发现打印顺序不一样，下面是测试情况： 按方法名升序执行，可以按照指定顺序执行： 按照JVM的返回顺序，顺序可能会不同。 以上，1/bugs，希望成为垫脚石T_T]]></content>
  </entry>
  <entry>
    <title><![CDATA[重写equals方法]]></title>
    <url>%2F2018%2F04%2F03%2Ftime-%202018-4-3%2F</url>
    <content type="text"><![CDATA[Override equals()虽然Object是一个具体类，但它有一些非final的方法是被设计成override的，必要的时候，我们需要按照约定覆盖它们，适用于所有的类，本文介绍如何覆盖equals方法。 什么时候需要覆盖equals方法？首先我们得先明白，未被覆盖的equals方法比较的是什么。未覆盖的equals方法比较的是两个对象是否引用同一块内存，如果是则返回true。往往我们有自己的“逻辑相等”概念去判断两个对象是否相同，这时！我们需要重写equals方法。 如何覆盖equals方法？当我们设计自己的“等价概念”时，是要遵守通用约定的，以下选自Object的规范： 自反性(reflexive)：对于任何非null的引用值x, x.equals(x)必须返回true。 对称性(symmetric)：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。 传递性(transitive)：对于任何非null的引用值x，y和z，如果x.equals(y)返回true,并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。 一致性(consistent)：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true，或者false。 对于然和非null的引用值x，x.equals(null)必须返回false。 在MIT-6.031-15的讲义中，看个小例子：1234567public class Duration &#123; ... // Problematic definition of equals() public boolean equals(Duration that) &#123; return this.getLength() == that.getLength(); &#125;&#125; 这样重写equals方法后，我们调用一段客户端代码发现：12345Duration d1 = new Duration (1, 2);Duration d2 = new Duration (1, 2);Object o2 = d2;d1.equals(d2) → trued1.equals(o2) → false 即使o2和d2指向同一个引用，但结果却不同。这是因为Duration类里对equals方法进行了overload并不是override正确override的方式是：123456@Overridepublic boolean equals (Object thatObject) &#123; if (!(thatObject instanceof Duration)) return false; Duration thatDuration = (Duration) thatObject; return this.getLength() == thatDuration.getLength();&#125; 大致按照这个框架，我们可以覆盖equals方法，然后检查它是否满足约定。 强调一下，instanceof关键字的作用是比较一个对象是否是一个类的实例。使用instanceof是一种动态类型检查，相较之下我们更喜欢静态的。除了在实现重写equals方法中，其他任何地方是禁止使用instanceof的。 重写hashCode方法覆盖了equals方法意味着必须要覆盖hashCode方法。如果不这样的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这些集合包括HashMap，HashSet，Hashtable。 我们要设计一个好的散列函数，让它为不相等的对象产生不相等的散列码。不求完美，我们应该尽量去接近理想状态。Effective Java介绍了一套如何设计散列函数的思想，参照《Effective Java》第9条可以了解。 参考资料：Effective Java：第8条，第9条MIT-6.031：Reading 15: EqualityObject规范]]></content>
  </entry>
  <entry>
    <title><![CDATA[MIT-6.031-13]]></title>
    <url>%2F2018%2F03%2F23%2FMIT6.031%2013%2F</url>
    <content type="text"><![CDATA[Reading 13:Abstraction Functions &amp; Rep Invariants关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。Reading 13:Abstraction Functions &amp; Rep Invariants Invariants一个好的抽象数据类型(以下简称ADT)，很重要的一点是，它要保护自己的不变性。注意，优秀ADT是自我保护不变性的，而不是依赖规范客户的行为。其实，当ADT可以自我保护的时候，程序员的工作也就更简化了，你可能调试更少的bug等等。 Immutability来，先看看不变性(immutable) 123456789101112131415161718192021/*** This immutable data type represents a tweet from Twitter.*/public class Tweet &#123; public String author; public String text; public Date timestamp; /** * Make a Tweet. * @param author Twitter user who wrote the tweet * @param text text of the tweet * @param timestamp date/time when the tweet was sent */ public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = timestamp; &#125;&#125; 一个问题，我们怎么保证一旦创建推特，作者，内容就不能改变？上面的示例，我们可以发现，用户可以访问所有内容，而并不能保证作者和内容不能修改的条件。 1234Tweet t = new Tweet("justinbieber", "Thanks to all those beliebers out there inspiring me every day", new Date());t.author = "rbmllr"; 可以这样直接修改作者，所以这是一个表示性暴露(representation exposure)的例子，意味着类外能直接修改类内的表示。改一下： 1234567891011121314151617181920212223242526public class Tweet &#123; private final String author; private final String text; private final Date timestamp; public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = timestamp; &#125; /** @return Twitter user who wrote the tweet */ public String getAuthor() &#123; return author; &#125; /** @return text of the tweet */ public String getText() &#123; return text; &#125; /** @return date/time when the tweet was sent */ public Date getTimestamp()&#123; return timestamp; &#125; private表示了属性只能在类内访问，public则表示可以在类外访问。final关键字则帮助我们确保了属性的不变性，final修饰的对象，一旦初始化后，值不能改变。但，其实依旧存在表示泄露(rep exposure), 我们来看一下如果用户这样操作： 123456/** @return a tweet that retweets t, one hour later*/public static Tweet retweetLater(Tweet t) &#123; Date d = t.getTimestamp(); d.setHours(d.getHours()+1); return new Tweet("rbmllr", t.getText(), d);&#125; 该方法retweetLater的功能是，get一条推特，1小时候用户重新发一条一样的推特(转发功能)。bug来了，Date是可变数据类型(mutable)，getTimestamp方法返回t的时间，类型是Date，且令d = t.getTimestamp(),这导致d指向了t的timestamp。然后d利用setHours改变了自己的时间，其实！这也就改变了t的时间，因为t和d都引用了同一块内存空间，看个快照会清楚一些：辛辛苦苦保护的属性，还是被破坏了……冷静分析一下问题所在，Tweet类泄露的可变的(mutable)的引用给客户。我们可以用防御式复制(defensive copying)来debug：复制可变数据(mutable)类型的对象，防止数据暴露给客户： 123public Date getTimestamp() &#123; return new Date(timestamp.getTime());&#125; 注意到没，返回的是一个新的Date，是不同于原来的timestamp的新的引用。可变数据类型(mutable)通常有一个复制构造函数(copy constructor)，允许你创建新实例复制已有实例的值。举个例子，StringBuilder的copy constructor需要一个String类型的数据。另一种复制一个可变数据类型的方法是clone()。 虽然我们采用了防御式复制，但我们还没完全解决表示性泄露(rep exposure)。看看下面这个用户代码： 12345678910/** @return a list of 24 inspiring tweets, one per hour today */public static List&lt;Tweet&gt; tweetEveryHourToday () &#123; List&lt;Tweet&gt; list = new ArrayList&lt;Tweet&gt;(); Date date = new Date(); for (int i = 0; i &lt; 24; i++) &#123; date.setHours(i); list.add(new Tweet("rbmllr", "keep it up! you can do it", date)); &#125; return list;&#125; 这段代码每小时创建一条tweet，但其实所有24条tweet的时间都是最后一条的时间，我们来看个快照图就很清楚：每条tweet引用的都是同一个date。我们可以改进一下之前的防御性复制，这样修改构造函数： 12345public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = new Date(timestamp.getTime());&#125; 一般来说，程序员应该仔细检查变量类型和返回的ADT类型。如果有可变(mutable)数据类型的，确保你的代码没有暴露它们的引用，防止rep exposure。 哎？你或许觉得这有点资源浪费？为什么非要复制啊？为什么不能直接在spec里写明白？像这样： 123456789/*Make a Tweet.- @param author Twitter user who wrote the tweet- @param text text of the tweet - @param timestamp date/time when the tweet was sent. Caller must never - mutate this Date object again!*/public Tweet(String author, String text, Date timestamp) &#123; 这种方法在“某些时候”是可行的，比如当可变数据类型过大的时候，防御性复制就很低效了。 虽然防御性复制损失空间，但总体来说很必要。为什么？我认为这是在赋予程序一种避免bug的的能力。所以ADT保护自己不变性，保护表示性不泄露，这是它的基础能力。 让你的ADT成为一个优秀的ADT吧！ 另一种是用不可变数据类型(immutable)，比如我们可以采用不可变的时间对象java.time.ZonedDateTime替换可变的java.util.Date。 Immutable wrappers around mutable data typesJava的集合类提供了一个有趣的折中：不可变包装器(immutable wrappers)////历史遗留问题////// Rep invariant and abstraction function我们设计ADT时，可以考虑“两种值的空间”的关系。两种值的空间，喵喵喵？介绍一下它们：1.暴露给客户的值的组成空间(rep values)：这个空间由实例化后的值组成。简言之，你的ADT会实例成一个对象吧？但更常见的是，我们经常需要一个小型的网络对象，所以这个值，是非常复杂的。2.抽象值空间(abstract values)：由你设计的ADT支持的抽象数据类型组成。比如，一个无边界整型的抽象值空间可能是数学上的整数，实际上，它被实现为一个基本类型的整型数组(有界的)。 现在，假设，我们采用一个字符串代表一组字符： 1234public class CharSet &#123; private String s; ...&#125; R(rep values)包含了字符串，A(abstract values)包含了字符的数学集合。 A中每个值都能在R中找到原象，即这个映射关系是满射的。 A中一些值可以在R中找到不止一个原象。 R中不是所有的值都有映射。满射，不一定单射，所以不一定双射。例如“abbc”是非法字符串，因为我们定义不能内含重复字符。 我们为了刻画这两个空间的关系，给出两个定义：1.AF：一个抽象函数映射使得R-&gt;A AF: R-&gt;A 2.RI：个人理解为一个衡量R是否合格的指标 RI: R-&gt;boolean RI可以被形容为一个集合，是AF成立的子集。 我们应该在代码中记录AF和RI，紧挨着你设计的数据表示(rep)，比如： 12345678public class CharSet &#123; private String s; // Rep invariant: // s contains no repeated characters // Abstraction Function: // represents the set of characters found in s ...&#125;]]></content>
      <categories>
        <category>MIT</category>
      </categories>
      <tags>
        <tag>MIT讲义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT-6.031-07]]></title>
    <url>%2F2018%2F03%2F20%2FMIT6.031%2007%2F</url>
    <content type="text"><![CDATA[Reading 7:Designing Specifications关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。MIT-6.031-07 Reading 7 : Designing Specifications Introduction本文主要从不同的specs实例对比中，介绍如何设计specs。 确定性(deterministic)：规格是否定义明确？例如一个输入对应一个输出，还是可以有多种可能。 说明性()：规格是否说明“到位”？例如是否说明了如何输入，或者对输出结果的要求。 强度：是否有足够的数据集支撑？例如一个合理的小数集，或者大集合（显然两者起到不同的作用）。 上述三个维度有时不可兼得，则我们根据实际权衡，折中达到最优。 Deterministic VS underdetermined specsstatic int findFirst(int[] arr, int val) { for (int i = 0; i &lt; arr.length; i++) { if (arr[i] == val) return i; } return arr.length; } static int findLast(int[] arr, int val) { for (int i = arr.length - 1 ; i &gt;= 0; i--) { if (arr[i] == val) return i; } return -1; } 上面是两个方法,First和Last只是为了区分它们的实现方式。在实际代码中，它们都是find方法。再来看一下find的规格(specification): static int findExactlyOne(int[] arr, int val) requires: val occurs exactly once in arr effects: returns index i such that arr[i] = val 这个规格findExactlyOne是确定(deterministic)的：即当输入满足前置条件时，findFirst和findLast方法都可以正确输出，即达成后置条件。 这里，还有另一个规格findOneOrMore,AnyIndex： static int findOneOrMore,AnyIndex(int[] arr, int val) requires: val occurs in arr effects: returns index i such that arr[i] = val 它不同于findExactlyOne的是，前置条件变成了val在arr中出现即可，这样弱化了前置条件，导致这个规格是不确定的。若val多次出现，则effects并没有说明返回的index是哪一个，它是不确定的。 注意，此处的不确定并不是传统意义的。费确定性代码指的是，给它相同的输入，可能会有不同的输出。为了避免混淆，我们把这种不确定性称为 underdetermined。 Declarative VS operational specs大致可以分成两种：Declarative spec和Operational spec。声明性的(Declarative spec)：不会描述细节和中间过程。反而注重描述输出结果的属性，与初始输入的关系。操作性的(Operational spec)：描述了方法执行的步骤，细节等，例如伪代码。 对于spec，我们更青睐Declarative spec ,因为它简短，易于理解，且更重要的是，它不会暴露具体实现的细节给客户。 但是，有时程序员会在spec里写操作性的实现细节利于维护者维护。注意，这不是一个好习惯！这可以在方法内部进行说明，但一定不要让它出现在spec里。 举个例子吧： static String join(String delimiter, String[] elements) effects: append together the strings in elements, but at each step, if there are more elements left, insert delimiter 这是一个操作性的(operational)spec。修改它，让它变得declarative，可以这样： effects: returns concatenation of elements in order, with delimiter inserted between each pair of adjacent elements 更改之后，仅仅说明了属性，没有暴露具体实现。 Stronger VS weaker specs现在我们来考虑这种情况：假设你想要改变一个方法，无视方法的具体实现和spec本身。现在已经有客户采用已有的spec了。是新写一个spec呢？还是用原来的就可以？以上得出，我们需要一个标准来判断两个spec的强弱。S2强于S1，则： S2的前置条件弱于S1 S2的后置条件强于S1 简言之，想要加强一个spec，弱化前置，强化后置。 为什么要强化spec？取代原有spec。发现了没，这种“强化升级”，其实也提升了用户体验。减少对用户的需求，却增加了“回报”，让用户放心。 来，再看看我们之前提到的specs： static int findExactlyOne(int[] a, int val) requires: val occurs exactly once in a effects: returns index i such that a[i] = val 弱化前置条件： static int findOneOrMore,AnyIndex(int[] a, int val) requires: val occurs at least once in a effects: returns index i such that a[i] = val 强化后置条件： static int findOneOrMore,FirstIndex(int[] a, int val) requires: val occurs at least once in a effects: returns lowest index i such that a[i] = val 再强化后置条件： static int findCanBeMissing(int[] a, int val) requires: nothing effects: returns index i such that a[i] = val,or -1 if no such i Diagramming specification我们可以利用图形表示spec，往往更清晰更直观。 假设Java世界是一个无限空间，我们用一个点代表一个方法，就像这样： spec是有一个合理范围的，对于能实现该spec的方法，我们把它放在范围内，反之则在范围外。findFirst和findLast都满足findOneOrMore,AnyIndex，所以在范围内： 再后来我们做了什么事情呢？我们强化了findOneOrMore,AnyIndex，问题来了，怎么表示？1.强化后置：这意味着程序员需要对输出更严格，这导致有的方法之前满足findOneOrMore,AnyIndex(S1)，但现在不满足findOneOrMore,FirstIndex(S2)，那它在S2外，S1里。2.弱化前置：这意味着要处理更多的输入情况。下图中，S2强于S1，findLast在S2范围外，findFirst满足S2，在范围内。]]></content>
      <categories>
        <category>MIT</category>
      </categories>
      <tags>
        <tag>MIT讲义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven初步学习]]></title>
    <url>%2F2018%2F03%2F11%2FMaven%2F</url>
    <content type="text"><![CDATA[初次了解软件构造和maven，仅记录学习maven的过程。本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。 1. Maven？ Maven主要服务于基于Java平台的项目构建，项目信息管理。通俗一点说，Maven不仅是一个构建工具，它是一个自动化的构建工具。在软件开发中，其实是有专人负责去构建的(构建是一个过程，包含编译，测试，打包，部署等)，但Maven所做的是把构建的一系列工作像流水线一样自动完成。 2.Maven使用入门 POM.xmlPOM(Project Object Model,项目对象模型)，顾名思义，它定义了项目的基本信息，描述项目如何构建等。举一个简单的例子： 123456789&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt; &lt;artifactId&gt;Hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;project&gt; 可以发现代码中定义了groupId,artifactId,version：groupId一般是组织或者公司相关artifactId是唯一的，如上面的例子中是Hello-worldversion指定版本，SNAPSHOT意为快照，表示当前版本还在开发中，不稳定。 POM.xml可以说是整个Maven项目的核心，我们只需要修改POM.xml即可以达到不同的构建目标，声明依赖关系等。 Maven的文件夹默认格式Maven工程是自动化的，所以我们需要按照约定创建目录，这样Maven才能在自动化的构建过程中找到源文件，通常约定的结构是这样的：|—src 源码|—|—main 存放主程序|—|—|—java 存放Java源文件|—|—|—resources 存放框架或其他工具的配置文件|—|—test 存放测试程序|—|—|—java 存放Java测试的源文件|—|—|—resources 存放测试的配置文件|—POM.xml Maven工程的核心配置文件 手工生成上述目录可以说是很麻烦了，Maven解决了这个问题，提供Archetype帮助我们快速勾勒出项目骨架。 Maven3环境下，执行： mvn archetype:generate 然后会看到很多Archetype可供我们选择，这帮助我们快速构建项目骨架，节省了很多时间。 Eclipse下开发Maven工程：会自动生成上述文件目录，我们只需要按约定放好源文件即可。 Maven的构建过程概述 我们先看几个主要的Maven命令： mvn clean compile //编译 mvn clean test //测试 mvn clean package //打包 mvn clean install //安装项目输出的jar包到本地仓库中 先解释一下命令的含义，clean告诉Maven清理输出目录target/(默认情况下，Maven构建的所有输出都在该目录中)，compile告诉Maven编译项目主代码，项目主代码将会编译输出到target/classes目录下。 上述命令其实是对应了Maven的插件以及插件目标，clean是clean插件的目标，test是test插件 的目标。 编译—-&gt;测试—-&gt;打包—-&gt;安装 执行test之前会执行compile，同样执行package之前会执行test。 3.Maven坐标和依赖 坐标这个概念始于平面几何，它可以用来唯一的标识一个元素。《Maven实战中》里，很生动的将其描述为： Maven给Java类库(例如jar文件)世界引入了经纬，让他们变得有秩序，于是我们可以借助它来有序的管理依赖，轻松的解决那些繁琐的依赖问题。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>
