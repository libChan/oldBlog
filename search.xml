<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的垃圾回收</title>
      <link href="/2018/06/22/Java%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2018/06/22/Java%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<p>Java GC将heap分成不同区域，不同区域采用不同的GC策略<br><a id="more"></a></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="Java-内存划分："><a href="#Java-内存划分：" class="headerlink" title="Java 内存划分："></a>Java 内存划分：</h3><p><img src="https://i.imgur.com/2iVNjeI.jpg" alt=""></p><ul><li>Young Generation：只有一小部分对象可较长时间存活，故采用<strong>copy算法</strong>减少GC代价</li><li>Old Generation：使用Mark-Sweep或Mark-Compact算法</li></ul><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>只有当Eden满的时候，才启动Minor GC<br><img src="https://i.imgur.com/YFdaADJ.jpg" alt=""></p><p>被引用的对象被复制到S0或S1，否则被垃圾回收掉：</p><p><img src="https://i.imgur.com/pvFalAK.jpg" alt=""><br>下一次垃圾回收：<br><img src="https://i.imgur.com/22FCRjx.jpg" alt=""><br>S0和S1始终至少有一个为空，下次GC时，Eden复制存活对象到空的区域，非空存活区也进行GC。<br>经历多次Minor GC存活的，被复制到Full GC</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>如果old generation满了，则启动full GC（MarkSweap-MarkCompact）<br> 当perm generation满了之后，无法存储更多的元数据，也启动full GC</p><p>堆尺寸参数：<br><img src="https://i.imgur.com/pridxQr.jpg" alt=""></p><p>参数设置：<br>Eden+存活区 ： 年老区 = 1：n<br>每个存活区：Eden = 1：n<br>old generation的尺寸不需要设置，根据其他各参数的取值可计算得到</p><h2 id="性能调优工具"><a href="#性能调优工具" class="headerlink" title="性能调优工具"></a>性能调优工具</h2><ul><li>jstat：获取JVM的heap使用和GC的性能统计数据</li><li>jmap：输出内存中的对象分布情况</li><li>jhat：导出heap dump，浏览/查询其中的对象分布情况</li><li>jstack：获取Java线程的stack trace</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向可维护性的设计模式</title>
      <link href="/2018/06/21/%E9%9D%A2%E5%90%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/21/%E9%9D%A2%E5%90%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ul><li>创建模式：工厂方法，抽象工厂方法，建造者方法</li><li>结构模式：桥梁，代理，组合</li><li>行为模式：中介，观察者，访问者，责任链，命令</li></ul><a id="more"></a><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类。</p><p>工厂模式给客户提供了便利，你到一个工厂，<strong>告诉他我要一辆车</strong>，然后你直接提车就行了，而不需要知道发动机是怎么造的。但是，将消息传递给工厂，这个过程很关键，<strong>你必须知道你要什么</strong>，工厂有则给你产品，没有……没有你就换一个工厂。</p><p>具体UML示例和代码实现参考<a href="http://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">工厂模式|菜鸟教程</a></p><p>优点：</p><ol><li>源代码与用户隔离</li><li>新增接口的实现类时，不需要修改原有的代码，直接扩展，满足开放封闭原则。</li></ol><p><strong>注意，用工厂方法创建的实例，返回类型是抽象接口类型。</strong></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Window</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repaint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScrollbar</span><span class="params">(…)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象产品实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PMWindow</span> <span class="keyword">implements</span> <span class="title">Window</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repaint</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotifWindow</span> <span class="keyword">implements</span> <span class="title">Window</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repaint</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractWidgetFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">createWindow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Scrollbar <span class="title">createScrollbar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteFactory1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetFactory1</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">createWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MSWindow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Scrollbar <span class="title">createScrollbar</span><span class="params">()</span></span>&#123;A&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConcreteFactory2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WidgetFactory2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">createWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MotifWindow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Scrollbar <span class="title">createScrollbar</span><span class="params">()</span></span>&#123;B&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Builder（构造器模式）"><a href="#Builder（构造器模式）" class="headerlink" title="Builder（构造器模式）"></a>Builder（构造器模式）</h3><p><img src="https://i.imgur.com/qEWM3UU.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Product" */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String dough = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">private</span> String sauce = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">private</span> String topping = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDough</span><span class="params">(String dough)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.dough = dough;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSauce</span><span class="params">(String sauce)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sauce = sauce;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTopping</span><span class="params">(String topping)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.topping = topping;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Abstract Builder" */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaBuilder</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> Pizza pizza;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">getPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNewPizzaProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza = <span class="keyword">new</span> Pizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDough</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSauce</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTopping</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "ConcreteBuilder 1" */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpicyPizzaBuilder</span> <span class="keyword">extends</span> <span class="title">PizzaBuilder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setDough(<span class="string">"pan baked"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setSauce(<span class="string">"hot"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setTopping(<span class="string">"pepperoni+salami"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "ConcreteBuilder 2" */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HawaiianPizzaBuilder</span> <span class="keyword">extends</span> <span class="title">PizzaBuilder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setDough(<span class="string">"cross"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setSauce(<span class="string">"mild"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizza.setTopping(<span class="string">"ham+pineapple"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Director类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Director" */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> PizzaBuilder pizzaBuilder; <span class="comment">//delegation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPizzaBuilder</span><span class="params">(PizzaBuilder pb)</span> </span>&#123;</span><br><span class="line">pizzaBuilder = pb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到builder的最终结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">getPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pizzaBuilder.getPizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构建pizza每一部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constructPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pizzaBuilder.createNewPizzaProduct();</span><br><span class="line">pizzaBuilder.buildDough();</span><br><span class="line">pizzaBuilder.buildSauce();</span><br><span class="line">pizzaBuilder.buildTopping();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A customer ordering a pizza. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaBuilderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Waiter waiter = <span class="keyword">new</span> Waiter();<span class="comment">//director</span></span><br><span class="line">PizzaBuilder hawaiianPizzabuilder = <span class="keyword">new</span> HawaiianPizzaBuilder();<span class="comment">//builder1</span></span><br><span class="line">PizzaBuilder spicyPizzaBuilder = <span class="keyword">new</span> SpicyPizzaBuilder();<span class="comment">//builder2</span></span><br><span class="line">waiter.setPizzaBuilder( hawaiianPizzabuilder );<span class="comment">//delegation</span></span><br><span class="line">waiter.constructPizza();<span class="comment">//获得build后的实例</span></span><br><span class="line">Pizza pizza = waiter.getPizza();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建的是一个完整的产品，有多个部分组成，client不需了解每个部分是怎么创建、各个部分怎么组合，最终得到一个产品的完整object</strong></p><p><img src="https://i.imgur.com/RaJB5X4.jpg" alt=""></p><h3 id="Bridge（桥接模式）"><a href="#Bridge（桥接模式）" class="headerlink" title="Bridge（桥接模式）"></a>Bridge（桥接模式）</h3><p><img src="https://i.imgur.com/pqYlfQH.jpg" alt=""></p><p><strong>抽象类(Abstraction)</strong>:定义抽象类的接口,维护一个指向Implementor类型对象的指针</p><p><strong>扩充抽象类(RefinedAbstraction)</strong>：扩充由Abstraction定义的接口</p><p><strong>实现类接口(Implementor)</strong>：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲， Implementor接口仅提供基本操作，而 Abstraction则定义了基于这些基本操作的较高层次的操作。</p><p><strong>具体实现类(ConcreteImplementor)</strong>：实现Implementor接口并定义它的具体实现。</p><p>Implementer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implementer实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawRedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(“Color: red <span class="string">" + radius + x + y);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawGreenCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(“Color: green <span class="string">" + radius + x + y);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.drawAPI = drawAPI;<span class="comment">//建立delegation link</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩充继承类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(drawAPI);</span><br><span class="line"><span class="keyword">this</span>.x = x;  </span><br><span class="line"><span class="keyword">this</span>.y = y;  </span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">drawAPI.drawCircle(radius,x,y);<span class="comment">//将draw这个责任delegate到drawAPI这个接口的具体实例去执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><p>运行时在二者之间动态建立delegation关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> DrawRedCircle());</span><br><span class="line">Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> DrawGreenCircle());</span><br><span class="line">redCircle.draw();</span><br><span class="line">greenCircle.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bridge VS. Strategy</p><p><img src="https://i.imgur.com/5BytnJG.jpg" alt=""></p><h3 id="Proxy（代理模式）"><a href="#Proxy（代理模式）" class="headerlink" title="Proxy（代理模式）"></a>Proxy（代理模式）</h3><p>某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。</p><p><img src="https://i.imgur.com/NvlmmZA.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String fileName;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">loadFromDisk(fileName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span></span>&#123;…&#125;<span class="comment">//每次创建都要从磁盘装载，代价高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Image realImage;</span><br><span class="line"><span class="keyword">private</span> String fileName;</span><br><span class="line"><span class="keyword">public</span> ProxyImage fileName)&#123;</span><br><span class="line"><span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果display的时候发现没有装载，则再delegation</span></span><br><span class="line"><span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">&#125;</span><br><span class="line">realImage.display();<span class="comment">//Delegate到原来的类来完成具体装载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Image image = <span class="keyword">new</span> ProxyImage(“pic.jpg<span class="string">");</span></span><br><span class="line"><span class="string">image.display(); </span></span><br><span class="line"><span class="string">image.display();</span></span><br></pre></td></tr></table></figure><h3 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h3><p><strong>是用于把一组相似的对象当作一个单一的对象。</strong></p><p><strong>将对象组合成树形结构以表示”部分-整体”的层次结构。</strong></p><p><img src="https://i.imgur.com/QJz5BAY.jpg" alt=""></p><p>Employee类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">subordinates.add(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">subordinates.remove(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> subordinates;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;…&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <em>Employee</em> 类来创建和打印员工的层次结构</p><p><em>CompositePatternDemo.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Employee CEO = <span class="keyword">new</span> Employee(<span class="string">"John"</span>);</span><br><span class="line">Employee headSales = <span class="keyword">new</span> Employee(<span class="string">"Robert"</span>);</span><br><span class="line">Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">"Laura"</span>);</span><br><span class="line">Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line">CEO.add(headSales);</span><br><span class="line">clerk1.add(clerk1);</span><br><span class="line">clerk1.add(clerk2);</span><br><span class="line"></span><br><span class="line">System.out.println(CEO); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">System.out.println(headEmployee);</span><br><span class="line"><span class="keyword">for</span> (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">System.out.println(employee);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Composite VS Decorator</p><ul><li>Composite:  目的是在同类型的对象之间建立起树型层次结构，一个上层对象可包含多个下层对象.</li><li>Decorator:  强调的是同类型对象之间的“特性增加”问题，它们之间是平等的，区别在于 “拥有特性”的多少，每次decoration只能作用于一个object。</li></ul><h3 id="观察者模式（obsever）"><a href="#观察者模式（obsever）" class="headerlink" title="观察者模式（obsever）"></a>观察者模式（obsever）</h3><p><img src="https://i.imgur.com/mfh8Fmw.jpg" alt=""></p><p>“粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动<br>粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能）</p><h3 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h3><p><img src="https://i.imgur.com/OQLsMOP.jpg" alt=""><br>最好不要使用if/else结构在ADT内部实现状态转换（考虑将来的扩展和修改）</p><p>使用delegation，将状态转换的行为委派到独立的state对象去完成</p><h3 id="备忘录模式（-Memento-Pattern）"><a href="#备忘录模式（-Memento-Pattern）" class="headerlink" title="备忘录模式（ Memento Pattern）"></a>备忘录模式（ Memento Pattern）</h3><p><strong>记住对象的历史状态，以便于“回滚”</strong><br><img src="https://i.imgur.com/gMRbytv.jpg" alt=""></p><ul><li>Originator： 需要“备忘”的类</li><li>Caretaker： 添加originator的备忘记录和恢复</li><li>Memento：备忘录，记录originator对象的历史状态</li></ul><p>Originator:<br><img src="https://i.imgur.com/bDPaCZb.jpg" alt=""></p><p><img src="https://i.imgur.com/zVGD7Ab.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5个SOLID设计原则和GRASP</title>
      <link href="/2018/06/19/5%E4%B8%AASOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8CGRASP/"/>
      <url>/2018/06/19/5%E4%B8%AASOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8CGRASP/</url>
      <content type="html"><![CDATA[<p>面向健壮性编程的设计原则<br><a id="more"></a></p><ul><li><strong>SRP</strong>     The Single Responsibility Principle            单一责任原则</li><li><strong>OCP</strong>        The Open-Closed Principle                  开放-封闭原则</li><li><strong>LSP</strong>         The Liskov Substitution Principle             Liskov替换原则</li><li><strong>DIP</strong>         The Dependency Inversion Principle       依赖转置原则</li><li><strong>ISP</strong>          The Interface Segregation Principle         接口聚合原则</li></ul><h2 id="SRP（单一责任原则）"><a href="#SRP（单一责任原则）" class="headerlink" title="SRP（单一责任原则）"></a>SRP（单一责任原则）</h2><p>需要修改某个类的时候原因有且只有一个。<br>换句话说就是让一个类只承担一种类型责任，那么当这个类需要承当其他类型的责任的时候，就需要分解这个类。</p><blockquote><p>一个类，一个责任。</p></blockquote><p>这是一个违反了SRP的例子：</p><p><img src="https://i.imgur.com/xIWG8Y7.jpg" alt=""></p><h2 id="OCP（开放封闭原则）"><a href="#OCP（开放封闭原则）" class="headerlink" title="OCP（开放封闭原则）"></a>OCP（开放封闭原则）</h2><p><strong>对扩展开放，对修改封闭</strong></p><p>如何实现？抽象！为服务器端的代码（类型）抽象出一个抽象基类。<br><img src="https://i.imgur.com/8fjj0f7.jpg" alt=""></p><p>通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对<strong>修改的封闭</strong>。<br>当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对<strong>扩展的开放</strong>。</p><p>感觉OCP和Decorator的思想很相似，面临新的变化时，在原有的基础上独立出另一个功能。</p><h2 id="LSP（-Liskov替换原则）"><a href="#LSP（-Liskov替换原则）" class="headerlink" title="LSP（ Liskov替换原则）"></a>LSP（ Liskov替换原则）</h2><p>子类型必须能够替换父类型。</p><h2 id="ISP（接口分离原则）"><a href="#ISP（接口分离原则）" class="headerlink" title="ISP（接口分离原则）"></a>ISP（接口分离原则）</h2><p>客户端不应该被迫依赖于它们不用的接口。<strong>一个接口或者类应该拥有尽可能少的行为</strong>。</p><p>包含了无用方法的”胖接口”会增加类之间的耦合，可以分解为很多小接口。</p><h2 id="DIP（依赖倒置原则）"><a href="#DIP（依赖倒置原则）" class="headerlink" title="DIP（依赖倒置原则）"></a>DIP（依赖倒置原则）</h2><p><strong>高层模块不应该依赖底层模块，两者都应该依赖其抽象</strong></p><p>为什么细节类不应该彼此紧耦合，而要依赖于抽象？强耦合会导致代码面临新的变化时修改困难，难以扩展。</p><p>发现这一篇博客里的例子将这个想法讲得非常到位：<a href="https://blog.csdn.net/hfreeman2008/article/details/52289571" target="_blank" rel="noopener">依赖倒置原则</a></p><h2 id="GRASP"><a href="#GRASP" class="headerlink" title="GRASP"></a>GRASP</h2><p>General Responsibility Assignment Software Patterns <strong>通用职责分配软件模式</strong></p><p><strong>怎样设计类，分配它们的行为职责，以及明确类之间的相互关系等</strong></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向复用的设计模式</title>
      <link href="/2018/06/19/%E9%9D%A2%E5%90%91%E5%A4%8D%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/19/%E9%9D%A2%E5%90%91%E5%A4%8D%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>分为<strong>结构模式</strong>和<strong>行为模式</strong>展开<br>适配器模式，装饰器模式，外观模式，策略模式，模板模式，迭代器模式<br><a id="more"></a></p><h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><h3 id="Adapter-Pattern（适配器模式）"><a href="#Adapter-Pattern（适配器模式）" class="headerlink" title="Adapter Pattern（适配器模式）"></a>Adapter Pattern（适配器模式）</h3><p>适配器，顾名思义是两个不兼容接口的桥梁。<strong>适配器模式就是将一个接口/类转换成客户希望的接口。</strong></p><p>对象适配器模式：</p><p><img src="https://i.imgur.com/6DI19DB.png" alt=""></p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter2</span> <span class="keyword">implements</span> <span class="title">Voltage5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Voltage220 Voltage220;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter2</span><span class="params">(Voltage220 voltage220)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Voltage220 = voltage220;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原有的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>增加适配器类，通过委派（对象），将已有的转化为客户端需要的。</p></blockquote><h3 id="Decorator-Pattern（装饰器模式）"><a href="#Decorator-Pattern（装饰器模式）" class="headerlink" title="Decorator Pattern（装饰器模式）"></a>Decorator Pattern（装饰器模式）</h3><p>给一个现有的对象添加新的功能。</p><p>通过创建一个装饰类，包装原有的类，保持原有功能的情况下，提供额外功能。</p><p>UML：</p><p><img src="https://i.imgur.com/2piolJ0.jpg" alt=""></p><p>对象接口（Component）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Coffee类（ConcreteCompoent）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String description = <span class="string">"coffee"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰类（Decorator）：</p><p>抽象装饰类继承于接口Component，扩展ConcreteComponent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Drink decoratorDrink;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.decoratorDrink = decoratorDrink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratorDrink.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoratorDrink.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Milk类（实现Decorator）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratorDrink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">" milk"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sugar类（实现Decorator）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sugar</span><span class="params">(Drink decoratorDrink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(decoratorDrink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">" sugar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeShop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点一杯coffee</span></span><br><span class="line">        Drink drink = <span class="keyword">new</span> Coffee();</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">":"</span> + drink.cost());</span><br><span class="line">        <span class="comment">//加一份奶</span></span><br><span class="line">        drink = <span class="keyword">new</span> Milk(drink);</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">":"</span> + drink.cost());</span><br><span class="line">        <span class="comment">//加一份糖</span></span><br><span class="line">        drink = <span class="keyword">new</span> Sugar(drink);</span><br><span class="line">        System.out.println(drink.getDescription() + <span class="string">":"</span> + drink.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装饰类是独立于原有类的，所以可动态的添加或删除。</strong></p><h3 id="Facade-Pattern（外观模式）"><a href="#Facade-Pattern（外观模式）" class="headerlink" title="Facade Pattern（外观模式）"></a>Facade Pattern（外观模式）</h3><p>简化接口，提供一个统一的接口取代一系列的小接口，便于客户端学习。</p><p><img src="https://i.imgur.com/up4dC2S.jpg" alt=""></p><p>facade类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ModuleA a = <span class="keyword">new</span> ModuleA();</span><br><span class="line">    <span class="keyword">private</span> ModuleB b = <span class="keyword">new</span> ModuleB();</span><br><span class="line">    <span class="keyword">private</span>  ModuleC c = <span class="keyword">new</span> ModuleC();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.testA();</span><br><span class="line">        b.testB();</span><br><span class="line">        c.testC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子系统中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleA</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"调用ModuleA中的testA方法"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"调用ModuleB中的testB方法"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleC</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"调用ModuleC中的testC方法"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，原本执行test，需要执行a，b，c的test功能。</p><p>而通过Facade模式，不需要客户端接触处a，b，c，只用一个接口，完成了test。</p><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="Strategy（策略模式）"><a href="#Strategy（策略模式）" class="headerlink" title="Strategy（策略模式）"></a>Strategy（策略模式）</h3><p><img src="https://i.imgur.com/5aOIloc.jpg" alt=""></p><p>Context类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个具体策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Strategy接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Strategy实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择并创建需要使用的策略对象</span></span><br><span class="line">        ConcreteStrategyB strategy = <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        <span class="comment">//创建环境</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(strategy);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        context.contextInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Template-Pattern（模板模式）"><a href="#Template-Pattern（模板模式）" class="headerlink" title="Template Pattern（模板模式）"></a>Template Pattern（模板模式）</h3><p>定义一个操作的骨架（抽象类）。使用继承和重写实现模板模式。</p><p>菜鸟教程的这部分讲得很不错：<a href="http://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">模板模式|菜鸟教程</a></p><h3 id="Iterator-Pattern（迭代器模式）"><a href="#Iterator-Pattern（迭代器模式）" class="headerlink" title="Iterator Pattern（迭代器模式）"></a>Iterator Pattern（迭代器模式）</h3><p>让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext, next, remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。</p><p>UML：</p><p><img src="https://i.imgur.com/BEZFdh7.jpg" alt=""></p><p>Aggregate：聚合接口，聚合类，用来存储迭代器的数据，其中有一个获得迭代器的方法。</p><p>Iterator：迭代器用来为聚集类提供服务，提供了一系列访问聚集类对象元素的方法。</p><p>具体代码实例可以参考<a href="https://www.cnblogs.com/cxxjohnson/p/6403851.html" target="_blank" rel="noopener">迭代器模式</a></p><p>感谢参考：</p><p><a href="https://blog.csdn.net/wwh578867817/article/details/51480441" target="_blank" rel="noopener">Decorator</a></p><p><a href="https://blog.csdn.net/jason0539/article/details/22775311" target="_blank" rel="noopener">Facade</a></p><p><a href="https://blog.csdn.net/l_lhc/article/details/50685225" target="_blank" rel="noopener">Strategy</a></p><p><a href="http://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">模板模式|菜鸟教程</a></p><p><a href="https://www.cnblogs.com/cxxjohnson/p/6403851.html" target="_blank" rel="noopener">迭代器模式</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈Java中的Dispatch(分派)和Binding(绑定)</title>
      <link href="/2018/06/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84Dispatch(%E5%88%86%E6%B4%BE)%E5%92%8CBinding(%E7%BB%91%E5%AE%9A)/"/>
      <url>/2018/06/18/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84Dispatch(%E5%88%86%E6%B4%BE)%E5%92%8CBinding(%E7%BB%91%E5%AE%9A)/</url>
      <content type="html"><![CDATA[<p>Java中，绑定是指将方法名和具体方法绑定的过程。</p><p>而分派是在运行阶段，对已经绑定好的方法实行分配，决定该调用哪个方法。</p><a id="more"></a><h2 id="Binding：绑定"><a href="#Binding：绑定" class="headerlink" title="Binding：绑定"></a>Binding：绑定</h2><p>绑定可以分为<strong>前期绑定</strong>和<strong>后期绑定</strong></p><ol><li><p>前期/静态绑定</p><p>Java中的static，final，private的方法属于前期绑定。需要注意的是，Overload是静态绑定的。静态绑定在编译阶段完成。</p></li><li><p>后期/动态绑定</p><p>对Override的方法进行绑定，在运行时根据具体对象的类型进行绑定。</p><p>编译阶段，编译器还不知道对象的具体类型（例如不知道该对象调用子类的方法还是父类的方法）。</p><p>以父类型与子类型的转换为例，动态绑定大致过程如下：</p><ul><li>编译器列出对象可能的所有方法表（父类+子类等）</li><li>运行时，匹配方法。</li></ul></li></ol><h2 id="Dispatch：分派"><a href="#Dispatch：分派" class="headerlink" title="Dispatch：分派"></a>Dispatch：分派</h2><p>先绑定，后分派。分派决定在执行阶段执行哪一段代码。</p><ol><li><p>静态分派：</p><p>若绑定是确定的，一一对应，那么执行静态分派，在编译阶段即可执行。</p></li><li><p>动态分派：</p><p>方法绑定了多段代码，在运行阶段根据具体类型的对象决定执行哪段代码，</p><p>在运行阶段执行。</p></li></ol><p>Overload：提前绑定+动态分配</p><p>Override：延迟绑定+动态分配</p><p>所以<strong>动态分配不一定是延迟绑定，但延迟绑定一定意味着动态分配</strong>。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记几个Lab过程中的bug</title>
      <link href="/2018/06/03/%E8%AE%B0%E5%87%A0%E4%B8%AALab%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84bug/"/>
      <url>/2018/06/03/%E8%AE%B0%E5%87%A0%E4%B8%AALab%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84bug/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>Lab3-Lab5终于告一段落，持续了很久的实验，Lab3完成了程序的功能，Lab4补充功能并完成健壮性检查，Lab5主要进行I/O策略的优化，并分析程序运行情况。从实践学习Java的过程，会踩一些没有经验的坑，也是提升Java编程水平的过程。仅仅记录几个这个阶段的我学习过程中的bug，Java初学者，不正确的地方望指正。<br><a id="more"></a></p><h2 id="1-类内实例化自身"><a href="#1-类内实例化自身" class="headerlink" title="1. 类内实例化自身"></a>1. 类内实例化自身</h2><p>具体怎么萌生这个神奇的想法我也无从考据了T_T……我只知道后来一直在为自己曾经的脑洞买单T_T</p><p>看一看这个bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphPoet</span> <span class="keyword">extends</span> <span class="title">ConcreteGraph</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> GraphPoet graph = <span class="keyword">new</span> GraphPoet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么搞的下场是Stack overflow，冷静分析一下，当一个类存储在栈上，相应的存储他的成员，但存储成员时，又实例化了一个新的“自己”，如此反复，栈空间耗尽，车祸现场。</p><p>debug！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphPoet</span> <span class="keyword">extends</span> <span class="title">ConcreteGraph</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GraphPoet graph = <span class="keyword">new</span> GraphPoet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于当时的实验情况，加上关键字<code>static</code>就解决了栈溢出的问题，<strong>static是全局变量，当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例共用同一个static变量。</strong>所以在类的初始化时就创建了graph，实例化时则不再重复创建。</p><p>上述写法其实是不成熟的，当时对概念不够理解。后来发现对“静态变量“的使用是有所考究的，<strong>以下场景可以考虑使用静态变量</strong>：</p><ol><li>变量所包含的对象体积较大，占用内存较多。</li><li>变量所包含的对象生命周期较长。</li><li>变量所包含的对象数据稳定。</li><li>该类的对象实例有对该变量所包含的对象的共享需求。</li></ol><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h2><p>为什么说之前的代码是不成熟的，创建了一个static全局变量，全局变量可以直接通过类名调用，然而我却加上了private，Lab5思考到这个问题后，发现单例模式可以很好的应用在我的程序，满足需求，节省程序空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphPoet</span> <span class="keyword">extends</span> <span class="title">ConcreteGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GraphPoet graph = <span class="keyword">new</span> GraphPoet();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GraphPoet</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GraphPoet <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Junit的测试顺序"><a href="#3-Junit的测试顺序" class="headerlink" title="3.Junit的测试顺序"></a>3.Junit的测试顺序</h2><p>Junit的测试函数的执行顺序是不确定的，符合<code>单元测试</code>的思想。</p><p>Junit 4.11里增加了指定测试方法执行顺序的特性 </p><p>测试类的执行顺序可通过对测试类添加注解 “@FixMethodOrder(value)” 来指定,其中value 为执行顺序 </p><p>三种执行顺序：默认<code>MethodSorters.DEFAULT</code>，按方法名<code>MethodSorters.NAME_ASCENDING</code>，按JVM返回的顺序<code>MethodSorters.JVM</code>.</p><ul><li>*当没有指定任何顺序时，按默认来执行 ，多次执行发现打印顺序不一样，下面是测试情况：</li></ul><p><img src="https://i.imgur.com/LVyOvOQ.jpg" alt=""></p><ul><li>按方法名升序执行，可以按照指定顺序执行：</li></ul><p><img src="https://i.imgur.com/tsdoMHz.jpg" alt=""></p><ul><li>按照JVM的返回顺序，顺序可能会不同。</li></ul><p>以上，1/bugs，希望成为垫脚石T_T</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>重写equals方法</title>
      <link href="/2018/04/03/time-%202018-4-3/"/>
      <url>/2018/04/03/time-%202018-4-3/</url>
      <content type="html"><![CDATA[<h1 id="Override-equals"><a href="#Override-equals" class="headerlink" title="Override equals()"></a>Override equals()</h1><p>虽然Object是一个具体类，但它有一些非final的方法是被设计成override的，必要的时候，我们需要<strong>按照约定</strong>覆盖它们，适用于所有的类，本文介绍如何覆盖equals方法。<br><a id="more"></a></p><h2 id="什么时候需要覆盖equals方法？"><a href="#什么时候需要覆盖equals方法？" class="headerlink" title="什么时候需要覆盖equals方法？"></a>什么时候需要覆盖equals方法？</h2><p>首先我们得先明白，未被覆盖的equals方法比较的是什么。<br>未覆盖的equals方法比较的是两个对象是否引用同一块内存，如果是则返回true。<br>往往我们有自己的“逻辑相等”概念去判断两个对象是否相同，这时！我们需要重写equals方法。</p><h2 id="如何覆盖equals方法？"><a href="#如何覆盖equals方法？" class="headerlink" title="如何覆盖equals方法？"></a>如何覆盖equals方法？</h2><p>当我们设计自己的“等价概念”时，是要遵守通用约定的，以下选自Object的规范：</p><ul><li><p><strong>自反性(reflexive)</strong>：对于任何非null的引用值x, x.equals(x)必须返回true。</p></li><li><p><strong>对称性(symmetric)</strong>：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</p></li><li><p><strong>传递性(transitive)</strong>：对于任何非null的引用值x，y和z，如果x.equals(y)返回true,并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</p></li><li><p><strong>一致性(consistent)</strong>：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true，或者false。</p></li><li><p>对于然和非null的引用值x，x.equals(null)必须返回false。</p></li></ul><p>在MIT-6.031-15的讲义中，看个小例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Duration &#123;</span><br><span class="line">    ...   </span><br><span class="line">    // Problematic definition of equals()</span><br><span class="line">    public boolean equals(Duration that) &#123;</span><br><span class="line">        return this.getLength() == that.getLength();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样重写equals方法后，我们调用一段客户端代码发现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = new Duration (1, 2);</span><br><span class="line">Duration d2 = new Duration (1, 2);</span><br><span class="line">Object o2 = d2;</span><br><span class="line">d1.equals(d2) → true</span><br><span class="line">d1.equals(o2) → false</span><br></pre></td></tr></table></figure></p><p>即使<code>o2</code>和<code>d2</code>指向同一个引用，但结果却不同。这是因为<br><code>Duration</code>类里对equals方法<strong>进行了overload并不是override</strong><br>正确<code>override</code>的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals (Object thatObject) &#123;</span><br><span class="line">    if (!(thatObject instanceof Duration)) return false;</span><br><span class="line">    Duration thatDuration = (Duration) thatObject;</span><br><span class="line">    return this.getLength() == thatDuration.getLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大致按照这个框架，我们可以覆盖<code>equals</code>方法，然后检查它是否满足约定。</p><p>强调一下，<code>instanceof</code>关键字的作用是比较一个对象是否是一个类的实例。使用<code>instanceof</code>是一种动态类型检查，相较之下我们更喜欢静态的。<strong>除了在实现重写<code>equals</code>方法中，其他任何地方是禁止使用<code>instanceof</code>的。</strong></p><h2 id="重写hashCode方法"><a href="#重写hashCode方法" class="headerlink" title="重写hashCode方法"></a>重写hashCode方法</h2><p>覆盖了<code>equals</code>方法意味着<strong>必须要覆盖<code>hashCode</code></strong>方法。如果不这样的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这些集合包括HashMap，HashSet，Hashtable。</p><p>我们要设计一个好的散列函数，让它<strong>为不相等的对象产生不相等的散列码。</strong>不求完美，我们应该尽量去接近理想状态。<br>Effective Java介绍了一套如何设计散列函数的思想，参照《Effective Java》第9条可以了解。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>Effective Java：第8条，第9条<br>MIT-6.031：<a href="http://web.mit.edu/6.031/www/sp17/classes/15-equality/" target="_blank" rel="noopener">Reading 15: Equality</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">Object规范</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MIT-6.031-13</title>
      <link href="/2018/03/23/MIT6.031%2013/"/>
      <url>/2018/03/23/MIT6.031%2013/</url>
      <content type="html"><![CDATA[<h1 id="Reading-13-Abstraction-Functions-amp-Rep-Invariants"><a href="#Reading-13-Abstraction-Functions-amp-Rep-Invariants" class="headerlink" title="Reading 13:Abstraction Functions &amp; Rep Invariants"></a>Reading 13:Abstraction Functions &amp; Rep Invariants</h1><p>关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。<br><a href="http://web.mit.edu/6.031/www/sp17/classes/13-abstraction-functions-rep-invariants/#reading_13_abstraction_functions_rep_invariants" target="_blank" rel="noopener">Reading 13:Abstraction Functions &amp; Rep Invariants</a><br><a id="more"></a></p><h2 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h2><p>一个好的抽象数据类型(以下简称ADT)，很重要的一点是，它要<strong>保护自己的不变性</strong>。注意，优秀ADT是自我保护不变性的，而不是依赖规范客户的行为。<br>其实，当ADT可以自我保护的时候，程序员的工作也就更简化了，你可能调试更少的bug等等。</p><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>来，先看看不变性(immutable)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This immutable data type represents a tweet from Twitter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String author;</span><br><span class="line"><span class="keyword">public</span> String text;</span><br><span class="line"><span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个问题，我们怎么保证一旦创建推特，作者，内容就不能改变？<br>上面的示例，我们可以发现，用户可以访问所有内容，而并不能保证作者和内容不能修改的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tweet t = <span class="keyword">new</span> Tweet(<span class="string">"justinbieber"</span>, </span><br><span class="line"><span class="string">"Thanks to all those beliebers out there inspiring me every day"</span>, </span><br><span class="line"><span class="keyword">new</span> Date());</span><br><span class="line">t.author = <span class="string">"rbmllr"</span>;</span><br></pre></td></tr></table></figure><p>可以这样直接修改作者，所以这是一个<strong>表示性暴露(representation exposure)</strong>的例子，意味着类外能直接修改类内的表示。<br>改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String author;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date timestamp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> Twitter user who wrote the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> text of the tweet */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> date/time when the tweet was sent */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>private</code>表示了属性只能在类内访问，<code>public</code>则表示可以在类外访问。<code>final</code>关键字则帮助我们确保了属性的不变性，<code>final</code>修饰的对象，一旦初始化后，值不能改变。<br>但，其实依旧存在表示泄露(rep exposure), 我们来看一下如果用户这样操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a tweet that retweets t, one hour later*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tweet <span class="title">retweetLater</span><span class="params">(Tweet t)</span> </span>&#123;</span><br><span class="line">Date d = t.getTimestamp();</span><br><span class="line">d.setHours(d.getHours()+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Tweet(<span class="string">"rbmllr"</span>, t.getText(), d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法<code>retweetLater</code>的功能是，get一条推特，1小时候用户重新发一条一样的推特(转发功能)。<br>bug来了，Date是可变数据类型(mutable)，<code>getTimestamp</code>方法返回t的时间，类型是Date，且令d = t.getTimestamp(),这导致d指向了t的timestamp。然后d利用<code>setHours</code>改变了自己的时间，其实！这也就改变了t的时间，因为t和d都引用了同一块内存空间，看个快照会清楚一些：<br><img src="https://i.imgur.com/FpBVhxj.jpg" alt=""><br>辛辛苦苦保护的属性，还是被破坏了……<br>冷静分析一下问题所在，<code>Tweet</code>类泄露的可变的(mutable)的引用给客户。<br>我们可以用<strong>防御式复制(defensive copying)</strong>来debug：复制可变数据(mutable)类型的对象，防止数据暴露给客户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到没，返回的是一个新的Date，是不同于原来的timestamp的新的引用。<br>可变数据类型(mutable)通常有一个复制构造函数(copy constructor)，允许你创建新实例复制已有实例的值。<br>举个例子，<code>StringBuilder</code>的copy constructor需要一个String类型的数据。另一种复制一个可变数据类型的方法是<code>clone()</code>。</p><p>虽然我们采用了防御式复制，但我们还没完全解决表示性泄露(rep exposure)。看看下面这个用户代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    date.setHours(i);</span><br><span class="line">    list.add(<span class="keyword">new</span> Tweet(<span class="string">"rbmllr"</span>, <span class="string">"keep it up! you can do it"</span>, date));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码每小时创建一条tweet，但其实所有24条tweet的时间都是最后一条的时间，我们来看个快照图就很清楚：<br><img src="https://i.imgur.com/KndNmHD.jpg" alt=""><br>每条tweet引用的都是同一个date。<br>我们可以改进一下之前的防御性复制，这样修改构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.author = author;</span><br><span class="line"><span class="keyword">this</span>.text = text;</span><br><span class="line"><span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，程序员应该仔细检查变量类型和返回的ADT类型。如果有可变(mutable)数据类型的，确保你的代码没有暴露它们的引用，防止rep exposure。</p><p>哎？你或许觉得这有点资源浪费？为什么非要复制啊？为什么不能直接在spec里写明白？像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Make a Tweet.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- @param author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment">- @param text      text of the tweet</span></span><br><span class="line"><span class="comment">  - @param timestamp date/time when the tweet was sent. Caller must never </span></span><br><span class="line"><span class="comment">  - mutate this Date object again!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>这种方法在“某些时候”是可行的，比如当可变数据类型过大的时候，防御性复制就很低效了。</p><p>虽然防御性复制损失空间，但总体来说很必要。为什么？我认为这是在赋予程序一种避免bug的的能力。所以ADT保护自己不变性，保护表示性不泄露，这是它的基础能力。</p><blockquote><p><strong>让你的ADT成为一个优秀的ADT吧！</strong></p></blockquote><p>另一种是用不可变数据类型(immutable)，比如我们可以采用不可变的时间对象<code>java.time.ZonedDateTime</code>替换可变的<code>java.util.Date</code>。</p><h3 id="Immutable-wrappers-around-mutable-data-types"><a href="#Immutable-wrappers-around-mutable-data-types" class="headerlink" title="Immutable wrappers around mutable data types"></a>Immutable wrappers around mutable data types</h3><p>Java的集合类提供了一个有趣的折中：<strong>不可变包装器(immutable wrappers)</strong><br>////历史遗留问题//////</p><h2 id="Rep-invariant-and-abstraction-function"><a href="#Rep-invariant-and-abstraction-function" class="headerlink" title="Rep invariant and abstraction function"></a>Rep invariant and abstraction function</h2><p>我们设计ADT时，可以考虑“两种值的空间”的关系。两种值的空间，喵喵喵？介绍一下它们：<br>1.暴露给客户的值的组成空间(rep values)：这个空间由实例化后的值组成。简言之，你的ADT会实例成一个对象吧？但更常见的是，我们经常需要一个小型的网络对象，所以这个值，是非常复杂的。<br>2.抽象值空间(abstract values)：由你设计的ADT支持的抽象数据类型组成。比如，一个无边界整型的抽象值空间可能是数学上的整数，实际上，它被实现为一个基本类型的整型数组(有界的)。</p><p>现在，假设，我们采用一个字符串代表一组字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/BIfiPgk.jpg" alt=""><br>R(rep values)包含了字符串，A(abstract values)包含了字符的数学集合。</p><ul><li>A中每个值都能在R中找到原象，即这个映射关系是满射的。</li><li>A中一些值可以在R中找到不止一个原象。</li><li>R中不是所有的值都有映射。<br>满射，不一定单射，所以不一定双射。<br>例如“abbc”是非法字符串，因为我们定义不能内含重复字符。</li></ul><p>我们为了刻画这两个空间的关系，给出两个定义：<br>1.AF：一个抽象函数映射使得R-&gt;A</p><blockquote><p>AF: R-&gt;A</p></blockquote><p>2.RI：个人理解为一个衡量R是否合格的指标</p><blockquote><p>RI: R-&gt;boolean</p></blockquote><p>RI可以被形容为一个集合，是AF成立的子集。</p><p>我们应该在代码中记录AF和RI，紧挨着你设计的数据表示(rep)，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"><span class="comment">// Rep invariant:</span></span><br><span class="line"><span class="comment">//    s contains no repeated characters</span></span><br><span class="line"><span class="comment">// Abstraction Function:</span></span><br><span class="line"><span class="comment">//   represents the set of characters found in s</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT讲义 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MIT-6.031-07</title>
      <link href="/2018/03/20/MIT6.031%2007/"/>
      <url>/2018/03/20/MIT6.031%2007/</url>
      <content type="html"><![CDATA[<h1 id="Reading-7-Designing-Specifications"><a href="#Reading-7-Designing-Specifications" class="headerlink" title="Reading 7:Designing Specifications"></a>Reading 7:Designing Specifications</h1><p>关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。<br><a href="http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/" target="_blank" rel="noopener">MIT-6.031-07 Reading 7 : Designing Specifications</a><br><a id="more"></a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本文主要从不同的specs实例对比中，介绍如何设计specs。</p><ol><li>确定性(deterministic)：规格是否定义明确？例如一个输入对应一个输出，还是可以有多种可能。</li><li>说明性()：规格是否说明“到位”？例如是否说明了如何输入，或者对输出结果的要求。</li><li>强度：是否有足够的数据集支撑？例如一个合理的小数集，或者大集合（显然两者起到不同的作用）。   </li></ol><p>上述三个维度有时不可兼得，则我们根据实际权衡，折中达到最优。</p><h2 id="Deterministic-VS-underdetermined-specs"><a href="#Deterministic-VS-underdetermined-specs" class="headerlink" title="Deterministic VS underdetermined specs"></a>Deterministic VS underdetermined specs</h2><pre><code>static int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}                   static int findLast(int[] arr, int val) {    for (int i = arr.length - 1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}</code></pre><p>上面是两个方法,First和Last只是为了区分它们的实现方式。在实际代码中，它们都是<code>find</code>方法。<br>再来看一下<code>find</code>的规格(specification):</p><pre><code>static int findExactlyOne(int[] arr, int val)requires: val occurs exactly once in arreffects:  returns index i such that arr[i] = val </code></pre><p><strong>这个规格<code>findExactlyOne</code>是确定(deterministic)的</strong>：即当输入满足前置条件时，<code>findFirst</code>和<code>findLast</code>方法都可以正确输出，即达成后置条件。</p><p>这里，还有另一个规格<code>findOneOrMore,AnyIndex</code>：</p><pre><code>static int findOneOrMore,AnyIndex(int[] arr, int val)requires: val occurs in arreffects:  returns index i such that arr[i] = val</code></pre><p>它不同于<code>findExactlyOne</code>的是，前置条件变成了val在arr中出现即可，这样弱化了前置条件，导致这个规格是不确定的。若val多次出现，则effects并没有说明返回的index是哪一个，<strong>它是不确定的</strong>。</p><p>注意，此处的<strong>不确定</strong>并不是传统意义的。费确定性代码指的是，给它相同的输入，可能会有不同的输出。<br>为了避免混淆，我们把这种不确定性称为<strong> underdetermined</strong>。</p><h2 id="Declarative-VS-operational-specs"><a href="#Declarative-VS-operational-specs" class="headerlink" title="Declarative VS operational specs"></a>Declarative VS operational specs</h2><p>大致可以分成两种：<code>Declarative spec</code>和<code>Operational spec</code>。<br>声明性的<code>(Declarative spec)</code>：不会描述细节和中间过程。反而注重描述输出结果的属性，与初始输入的关系。<br>操作性的<code>(Operational spec)</code>：描述了方法执行的步骤，细节等，例如伪代码。</p><p><strong> 对于spec，我们更青睐<code>Declarative spec</code> ,因为它简短，易于理解，且更重要的是，它不会暴露具体实现的细节给客户</strong>。</p><p>但是，有时程序员会在spec里写操作性的实现细节利于维护者维护。注意，这不是一个好习惯！这可以在方法内部进行说明，但一定不要让它出现在spec里。</p><p>举个例子吧：</p><pre><code>static String join(String delimiter, String[] elements)effects: append together the strings in elements, but at each step,         if there are more elements left, insert delimiter</code></pre><p>这是一个操作性的(operational)spec。<br>修改它，让它变得declarative，可以这样：</p><pre><code>effects: returns concatenation of elements in order,          with delimiter inserted between each pair of adjacent elements</code></pre><p>更改之后，仅仅说明了属性，没有暴露具体实现。</p><h2 id="Stronger-VS-weaker-specs"><a href="#Stronger-VS-weaker-specs" class="headerlink" title="Stronger VS weaker specs"></a>Stronger VS weaker specs</h2><p>现在我们来考虑这种情况：假设你想要改变一个方法，无视方法的具体实现和spec本身。现在已经有客户采用已有的spec了。是新写一个spec呢？还是用原来的就可以？<br>以上得出，我们需要一个标准来判断两个spec的强弱。S2强于S1，则：</p><ul><li>S2的前置条件弱于S1</li><li>S2的后置条件强于S1</li></ul><blockquote><p>简言之，想要加强一个spec，<strong>弱化前置，强化后置</strong>。</p></blockquote><p>为什么要强化spec？取代原有spec。<br>发现了没，这种“强化升级”，其实也提升了用户体验。减少对用户的需求，却增加了“回报”，让用户放心。</p><p>来，再看看我们之前提到的specs：</p><pre><code>static int findExactlyOne(int[] a, int val)requires: val occurs exactly once in aeffects:  returns index i such that a[i] = val</code></pre><p>弱化前置条件：</p><pre><code>static int findOneOrMore,AnyIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns index i such that a[i] = val</code></pre><p>强化后置条件：</p><pre><code>static int findOneOrMore,FirstIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns lowest index i such that a[i] = val</code></pre><p>再强化后置条件：</p><pre><code>static int findCanBeMissing(int[] a, int val)requires: nothingeffects:  returns index i such that a[i] = val,or -1 if no such i</code></pre><h2 id="Diagramming-specification"><a href="#Diagramming-specification" class="headerlink" title="Diagramming specification"></a>Diagramming specification</h2><p>我们可以利用图形表示spec，往往更清晰更直观。</p><ul><li>假设Java世界是一个无限空间，我们用一个点代表一个方法，就像这样：<br><img src="https://i.imgur.com/NLsYCzi.jpg" alt=""></li></ul><ul><li><p>spec是有一个合理范围的，对于能实现该spec的方法，我们把它放在范围内，反之则在范围外。<br><code>findFirst</code>和<code>findLast</code>都满足<code>findOneOrMore,AnyIndex</code>，所以在范围内：<br><img src="https://i.imgur.com/8caEGzH.jpg" alt=""></p></li><li><p>再后来我们做了什么事情呢？我们强化了<code>findOneOrMore,AnyIndex</code>，问题来了，怎么表示？<br>1.强化后置：<br>这意味着程序员需要对输出更严格，这导致有的方法之前满足<code>findOneOrMore,AnyIndex</code>(S1)，但现在不满足<code>findOneOrMore,FirstIndex</code>(S2)，那它在S2外，S1里。<br>2.弱化前置：<br>这意味着要处理更多的输入情况。<br>下图中，S2强于S1，<code>findLast</code>在S2范围外，<code>findFirst</code>满足S2，在范围内。<br><img src="https://i.imgur.com/9qoCpZX.jpg" alt=""></p></li></ul>]]></content>
      
      <categories>
          
          <category> MIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT讲义 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven初步学习</title>
      <link href="/2018/03/11/Maven/"/>
      <url>/2018/03/11/Maven/</url>
      <content type="html"><![CDATA[<p>初次了解软件构造和maven，仅记录学习maven的过程。<br>本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。<br><a id="more"></a></p><p><strong>1. Maven？</strong></p><p>Maven主要服务于基于Java平台的项目构建，项目信息管理。通俗一点说，Maven不仅是一个构建工具，它是一个<strong>自动化的构建工具</strong>。在软件开发中，其实是有专人负责去构建的(构建是一个过程，包含编译，测试，打包，部署等)，但Maven所做的是把构建的一系列工作<strong>像流水线一样自动完成</strong>。</p><p><strong>2.Maven使用入门</strong></p><ul><li><strong>POM.xml</strong><br>POM(Project Object Model,项目对象模型)，顾名思义，它<strong>定义了项目的基本信息，描述项目如何构建等</strong>。举一个简单的例子： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Hello-world&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>可以发现代码中定义了groupId,artifactId,version：<br>groupId一般是组织或者公司相关<br>artifactId是唯一的，如上面的例子中是Hello-world<br>version指定版本，SNAPSHOT意为快照，表示当前版本还在开发中，不稳定。</p><blockquote><p><strong>POM.xml可以说是整个Maven项目的核心，我们只需要修改POM.xml即可以达到不同的构建目标，声明依赖关系等。</strong></p></blockquote><ul><li><p><strong>Maven的文件夹默认格式</strong><br>Maven工程是自动化的，所以我们需要<strong>按照约定创建目录</strong>，这样Maven才能在自动化的构建过程中找到源文件，通常约定的结构是这样的：<br><strong><br>|—src                源码<br>|—|—main            存放主程序<br>|—|—|—java        存放Java源文件<br>|—|—|—resources    存放框架或其他工具的配置文件<br>|—|—test            存放测试程序<br>|—|—|—java        存放Java测试的源文件<br>|—|—|—resources    存放测试的配置文件<br>|—POM.xml                Maven工程的核心配置文件</strong></p><p>  手工生成上述目录可以说是很麻烦了，Maven解决了这个问题，提供<strong>Archetype</strong>帮助我们快速勾勒出项目骨架。<br>  Maven3环境下，执行：<br>  mvn archetype:generate<br>  然后会看到很多Archetype可供我们选择，这帮助我们快速构建项目骨架，节省了很多时间。<br>  Eclipse下开发Maven工程：会自动生成上述文件目录，我们只需要按约定放好源文件即可。</p></li></ul><ul><li><p><strong>Maven的构建过程概述</strong></p><p>  我们先看几个主要的Maven命令：<br>  mvn clean compile     //编译<br>  mvn clean test        //测试<br>  mvn clean package    //打包<br>  mvn clean install    //安装项目输出的jar包到本地仓库中</p><p>  先解释一下命令的含义，clean告诉Maven清理输出目录target/(默认情况下，Maven构建的所有输出都在该目录中)，compile告诉Maven编译项目主代码，项目主代码将会编译输出到target/classes目录下。<br>  上述命令其实是对应了Maven的插件以及插件目标，clean是clean插件的目标，test是test插件    的目标。</p><p>  <strong>编译—-&gt;测试—-&gt;打包—-&gt;安装</strong><br>  执行test之前会执行compile，同样执行package之前会执行test。</p></li></ul><p><strong>3.Maven坐标和依赖</strong>  </p><p>坐标这个概念始于平面几何，它可以用来唯一的标识一个元素。<br>《Maven实战中》里，很生动的将其描述为：</p><blockquote><p>Maven给Java类库(例如jar文件)世界引入了经纬，让他们变得有秩序，于是我们可以借助它来有序的管理依赖，轻松的解决那些繁琐的依赖问题。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
