<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的垃圾回收]]></title>
    <url>%2F2018%2F06%2F22%2FJava%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[Java GC将heap分成不同区域，不同区域采用不同的GC策略 垃圾回收Java 内存划分： Young Generation：只有一小部分对象可较长时间存活，故采用copy算法减少GC代价 Old Generation：使用Mark-Sweep或Mark-Compact算法 Minor GC只有当Eden满的时候，才启动Minor GC 被引用的对象被复制到S0或S1，否则被垃圾回收掉： 下一次垃圾回收：S0和S1始终至少有一个为空，下次GC时，Eden复制存活对象到空的区域，非空存活区也进行GC。经历多次Minor GC存活的，被复制到Full GC Full GC如果old generation满了，则启动full GC（MarkSweap-MarkCompact） 当perm generation满了之后，无法存储更多的元数据，也启动full GC 堆尺寸参数： 参数设置：Eden+存活区 ： 年老区 = 1：n每个存活区：Eden = 1：nold generation的尺寸不需要设置，根据其他各参数的取值可计算得到 性能调优工具 jstat：获取JVM的heap使用和GC的性能统计数据 jmap：输出内存中的对象分布情况 jhat：导出heap dump，浏览/查询其中的对象分布情况 jstack：获取Java线程的stack trace]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向可维护性的设计模式]]></title>
    <url>%2F2018%2F06%2F21%2F%E9%9D%A2%E5%90%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[创建模式：工厂方法，抽象工厂方法，建造者方法 结构模式：桥梁，代理，组合 行为模式：中介，观察者，访问者，责任链，命令 创建模式工厂模式当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体创建的实例时，用工厂方法。定义一个用于创建对象的接口，让其子类来决定实例化哪一个类。 工厂模式给客户提供了便利，你到一个工厂，告诉他我要一辆车，然后你直接提车就行了，而不需要知道发动机是怎么造的。但是，将消息传递给工厂，这个过程很关键，你必须知道你要什么，工厂有则给你产品，没有……没有你就换一个工厂。 具体UML示例和代码实现参考工厂模式|菜鸟教程 优点： 源代码与用户隔离 新增接口的实现类时，不需要修改原有的代码，直接扩展，满足开放封闭原则。 注意，用工厂方法创建的实例，返回类型是抽象接口类型。 抽象工厂模式抽象产品： 12345public interface Window&#123; public void setTitle(String s); public void repaint(); public void addScrollbar(…); &#125; 抽象产品实现类： 1234public class PMWindow implements Window&#123; public void setTitle()&#123;…&#125; public void repaint()&#123;…&#125;&#125; 1234public class MotifWindow implements Window&#123; public void setTitle()&#123;…&#125; public void repaint()&#123;…&#125;&#125; 抽象工厂接口： 1234public interface AbstractWidgetFactory&#123; public Window createWindow(); public Scrollbar createScrollbar();&#125; 抽象工厂实现类： 1234567//ConcreteFactory1public class WidgetFactory1&#123; public Window createWindow()&#123; return new MSWindow(); &#125; public Scrollbar createScrollbar()&#123;A&#125;&#125; 1234567//ConcreteFactory2public class WidgetFactory2&#123; public Window createWindow()&#123; return new MotifWindow(); &#125; public Scrollbar createScrollbar()&#123;B&#125;&#125; Builder（构造器模式） 12345678910111213141516/* "Product" */class Pizza &#123; private String dough = ""; private String sauce = ""; private String topping = ""; public void setDough(String dough) &#123; this.dough = dough; &#125; public void setSauce(String sauce) &#123; this.sauce = sauce; &#125; public void setTopping(String topping) &#123; this.topping = topping; &#125;&#125; Builder抽象类： 12345678910111213/* "Abstract Builder" */abstract class PizzaBuilder &#123; protected Pizza pizza; public Pizza getPizza() &#123; return pizza; &#125; public void createNewPizzaProduct() &#123; pizza = new Pizza(); &#125; public abstract void buildDough(); public abstract void buildSauce(); public abstract void buildTopping();&#125; Builder实现类： 123456789101112/* "ConcreteBuilder 1" */class SpicyPizzaBuilder extends PizzaBuilder &#123; public void buildDough() &#123; pizza.setDough("pan baked"); &#125; public void buildSauce() &#123; pizza.setSauce("hot"); &#125; public void buildTopping() &#123; pizza.setTopping("pepperoni+salami"); &#125;&#125; 123456789101112/* "ConcreteBuilder 2" */class HawaiianPizzaBuilder extends PizzaBuilder &#123; public void buildDough() &#123; pizza.setDough("cross"); &#125; public void buildSauce() &#123; pizza.setSauce("mild"); &#125; public void buildTopping() &#123; pizza.setTopping("ham+pineapple"); &#125;&#125; Director类: 123456789101112131415161718/* "Director" */class Waiter &#123; private PizzaBuilder pizzaBuilder; //delegation public void setPizzaBuilder(PizzaBuilder pb) &#123; pizzaBuilder = pb; &#125; //得到builder的最终结果 public Pizza getPizza() &#123; return pizzaBuilder.getPizza(); &#125; //具体构建pizza每一部分 public void constructPizza() &#123; pizzaBuilder.createNewPizzaProduct(); pizzaBuilder.buildDough(); pizzaBuilder.buildSauce(); pizzaBuilder.buildTopping(); &#125;&#125; 客户端调用： 1234567891011/* A customer ordering a pizza. */public class PizzaBuilderDemo &#123; public static void main(String[] args) &#123; Waiter waiter = new Waiter();//director PizzaBuilder hawaiianPizzabuilder = new HawaiianPizzaBuilder();//builder1 PizzaBuilder spicyPizzaBuilder = new SpicyPizzaBuilder();//builder2 waiter.setPizzaBuilder( hawaiianPizzabuilder );//delegation waiter.constructPizza();//获得build后的实例 Pizza pizza = waiter.getPizza(); &#125;&#125; 创建的是一个完整的产品，有多个部分组成，client不需了解每个部分是怎么创建、各个部分怎么组合，最终得到一个产品的完整object Bridge（桥接模式） 抽象类(Abstraction):定义抽象类的接口,维护一个指向Implementor类型对象的指针 扩充抽象类(RefinedAbstraction)：扩充由Abstraction定义的接口 实现类接口(Implementor)：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来讲， Implementor接口仅提供基本操作，而 Abstraction则定义了基于这些基本操作的较高层次的操作。 具体实现类(ConcreteImplementor)：实现Implementor接口并定义它的具体实现。 Implementer: 123public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125; Implementer实现类： 123456public class DrawRedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(“Color: red " + radius + x + y); &#125;&#125; 123456public class DrawGreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(“Color: green " + radius + x + y); &#125;&#125; 抽象类： 1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI;//建立delegation link &#125; public abstract void draw();&#125; 扩充继承类： 123456789101112public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y);//将draw这个责任delegate到drawAPI这个接口的具体实例去执行 &#125;&#125; 客户端调用： 运行时在二者之间动态建立delegation关系 12345678public class BridgePatternDemo &#123;public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new DrawRedCircle()); Shape greenCircle = new Circle(100,100, 10, new DrawGreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125; Bridge VS. Strategy Proxy（代理模式）某个对象比较“敏感”/“私密”/“贵重”，不希望被client直接访问到，故设置proxy，在二者之间建立防火墙。 123public interface Image &#123; void display();&#125; 12345678910public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123;…&#125; private void loadFromDisk(String fileName)&#123;…&#125;//每次创建都要从磁盘装载，代价高&#125; Proxy类： 123456789101112131415public class ProxyImage implements Image &#123; private Image realImage; private String fileName; public ProxyImage fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; //如果display的时候发现没有装载，则再delegation if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display();//Delegate到原来的类来完成具体装载 &#125;&#125; 客户端调用： 123Image image = new ProxyImage(“pic.jpg");image.display(); image.display(); 组合模式（Composite）是用于把一组相似的对象当作一个单一的对象。 将对象组合成树形结构以表示”部分-整体”的层次结构。 Employee类： 123456789101112131415161718public class Employee &#123; private String name; private List&lt;Employee&gt; subordinates; public Employee(String name) &#123; this.name = name; subordinates = new ArrayList&lt;Employee&gt;(); &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; public List&lt;Employee&gt; getSubordinates()&#123; return subordinates; &#125; public String toString()&#123;…&#125; &#125; 使用 Employee 类来创建和打印员工的层次结构 CompositePatternDemo.java 12345678910111213141516Employee CEO = new Employee("John");Employee headSales = new Employee("Robert");Employee clerk1 = new Employee("Laura");Employee clerk2 = new Employee("Bob");CEO.add(headSales);clerk1.add(clerk1);clerk1.add(clerk2);System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) &#123; System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) &#123; System.out.println(employee); &#125;&#125; Composite VS Decorator Composite: 目的是在同类型的对象之间建立起树型层次结构，一个上层对象可包含多个下层对象. Decorator: 强调的是同类型对象之间的“特性增加”问题，它们之间是平等的，区别在于 “拥有特性”的多少，每次decoration只能作用于一个object。 观察者模式（obsever） “粉丝”对“偶像”感兴趣，希望随时得知偶像的一举一动粉丝到偶像那里注册，偶像一旦有新闻发生，就推送给已注册的粉丝（回调callback粉丝的特定功能） 状态模式（State Pattern）最好不要使用if/else结构在ADT内部实现状态转换（考虑将来的扩展和修改） 使用delegation，将状态转换的行为委派到独立的state对象去完成 备忘录模式（ Memento Pattern）记住对象的历史状态，以便于“回滚” Originator： 需要“备忘”的类 Caretaker： 添加originator的备忘记录和恢复 Memento：备忘录，记录originator对象的历史状态 Originator:]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5个SOLID设计原则和GRASP]]></title>
    <url>%2F2018%2F06%2F19%2F5%E4%B8%AASOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8CGRASP%2F</url>
    <content type="text"><![CDATA[面向健壮性编程的设计原则 SRP The Single Responsibility Principle 单一责任原则 OCP The Open-Closed Principle 开放-封闭原则 LSP The Liskov Substitution Principle Liskov替换原则 DIP The Dependency Inversion Principle 依赖转置原则 ISP The Interface Segregation Principle 接口聚合原则 SRP（单一责任原则）需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只承担一种类型责任，那么当这个类需要承当其他类型的责任的时候，就需要分解这个类。 一个类，一个责任。 这是一个违反了SRP的例子： OCP（开放封闭原则）对扩展开放，对修改封闭 如何实现？抽象！为服务器端的代码（类型）抽象出一个抽象基类。 通过构造一个抽象的Server类：AbstractServer，该抽象类中包含针对所有类型的Server都通用的代码，从而实现了对修改的封闭。当出现新的Server类型时，只需从该抽象类中派生出具体的子类ConcreteServer即可，从而支持了对扩展的开放。 感觉OCP和Decorator的思想很相似，面临新的变化时，在原有的基础上独立出另一个功能。 LSP（ Liskov替换原则）子类型必须能够替换父类型。 ISP（接口分离原则）客户端不应该被迫依赖于它们不用的接口。一个接口或者类应该拥有尽可能少的行为。 包含了无用方法的”胖接口”会增加类之间的耦合，可以分解为很多小接口。 DIP（依赖倒置原则）高层模块不应该依赖底层模块，两者都应该依赖其抽象 为什么细节类不应该彼此紧耦合，而要依赖于抽象？强耦合会导致代码面临新的变化时修改困难，难以扩展。 发现这一篇博客里的例子将这个想法讲得非常到位：依赖倒置原则 GRASPGeneral Responsibility Assignment Software Patterns 通用职责分配软件模式 怎样设计类，分配它们的行为职责，以及明确类之间的相互关系等]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向复用的设计模式]]></title>
    <url>%2F2018%2F06%2F19%2F%E9%9D%A2%E5%90%91%E5%A4%8D%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[分为结构模式和行为模式展开适配器模式，装饰器模式，外观模式，策略模式，模板模式，迭代器模式 结构模式Adapter Pattern（适配器模式）适配器，顾名思义是两个不兼容接口的桥梁。适配器模式就是将一个接口/类转换成客户希望的接口。 对象适配器模式： 接口： 123public interface Voltage5 &#123; int output5V();&#125; 适配器类： 12345678910public class VoltageAdapter2 implements Voltage5 &#123; private Voltage220 Voltage220; public VoltageAdapter2(Voltage220 voltage220) &#123; this.Voltage220 = voltage220; &#125; @Override public int output5V() &#123;&#125;&#125; 原有的类： 123public class Voltage220 &#123; public int output220V() &#123;&#125;&#125; 增加适配器类，通过委派（对象），将已有的转化为客户端需要的。 Decorator Pattern（装饰器模式）给一个现有的对象添加新的功能。 通过创建一个装饰类，包装原有的类，保持原有功能的情况下，提供额外功能。 UML： 对象接口（Component）： 1234public interface Drink &#123; public float cost(); public String getDescription();&#125; Coffee类（ConcreteCompoent）： 1234567891011public class Coffee implements Drink &#123; final private String description = "coffee"; public float cost() &#123; return 10; &#125; public String getDescription() &#123; return description; &#125;&#125; 装饰类（Decorator）： 抽象装饰类继承于接口Component，扩展ConcreteComponent 123456789101112131415public abstract class CondimentDecorator implements Drink &#123; protected Drink decoratorDrink; public CondimentDecorator(Drink decoratorDrink) &#123; this.decoratorDrink = decoratorDrink; &#125; public float cost() &#123; return decoratorDrink.cost(); &#125; public String getDescription() &#123; return decoratorDrink.getDescription(); &#125;&#125; Milk类（实现Decorator）： 123456789101112131415public class Milk extends CondimentDecorator &#123; public Milk(Drink decoratorDrink) &#123; super(decoratorDrink); &#125; @Override public float cost() &#123; return super.cost() + 2; &#125; @Override public String getDescription() &#123; return super.getDescription() + " milk"; &#125;&#125; Sugar类（实现Decorator）: 123456789101112131415public class Sugar extends CondimentDecorator &#123; public Sugar(Drink decoratorDrink) &#123; super(decoratorDrink); &#125; @Override public float cost() &#123; return super.cost() + 1; &#125; @Override public String getDescription() &#123; return super.getDescription() + " sugar"; &#125;&#125; Client调用： 12345678910111213public class CoffeeShop &#123; public static void main(String[] args) &#123; //点一杯coffee Drink drink = new Coffee(); System.out.println(drink.getDescription() + ":" + drink.cost()); //加一份奶 drink = new Milk(drink); System.out.println(drink.getDescription() + ":" + drink.cost()); //加一份糖 drink = new Sugar(drink); System.out.println(drink.getDescription() + ":" + drink.cost()); &#125;&#125; 装饰类是独立于原有类的，所以可动态的添加或删除。 Facade Pattern（外观模式）简化接口，提供一个统一的接口取代一系列的小接口，便于客户端学习。 facade类： 12345678910public class Facade &#123; private ModuleA a = new ModuleA(); private ModuleB b = new ModuleB(); private ModuleC c = new ModuleC(); public void test()&#123; a.testA(); b.testB(); c.testC(); &#125;&#125; 子系统中: 12345public class ModuleA &#123; public void testA()&#123; System.out.println("调用ModuleA中的testA方法"); &#125; &#125; 12345public class ModuleB &#123; public void testB()&#123; System.out.println("调用ModuleB中的testB方法"); &#125; &#125; 12345public class ModuleC &#123; public void testC()&#123; System.out.println("调用ModuleC中的testC方法"); &#125; &#125; 也就是说，原本执行test，需要执行a，b，c的test功能。 而通过Facade模式，不需要客户端接触处a，b，c，只用一个接口，完成了test。 行为模式Strategy（策略模式） Context类： 12345678910111213public class Context &#123; //持有一个具体策略的对象 private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public void contextInterface()&#123; strategy.strategyInterface(); &#125;&#125; Strategy接口： 123public interface Strategy &#123; public void strategyInterface();&#125; Strategy实现类： 123456public class ConcreteStrategyA implements Strategy &#123; @Override public void strategyInterface() &#123;&#125;&#125; 123456public class ConcreteStrategyB implements Strategy &#123; @Override public void strategyInterface() &#123;&#125;&#125; Client调用： 1234567891011public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 ConcreteStrategyB strategy = new ConcreteStrategyB(); //创建环境 Context context = new Context(strategy); //调用方法 context.contextInterface(); &#125;&#125; Template Pattern（模板模式）定义一个操作的骨架（抽象类）。使用继承和重写实现模板模式。 菜鸟教程的这部分讲得很不错：模板模式|菜鸟教程 Iterator Pattern（迭代器模式）让自己的集合类实现Iterable接口，并实现自己的独特Iterator迭代器(hasNext, next, remove)，允许客户端利用这个迭代器进行显式或隐式的迭代遍历。 UML： Aggregate：聚合接口，聚合类，用来存储迭代器的数据，其中有一个获得迭代器的方法。 Iterator：迭代器用来为聚集类提供服务，提供了一系列访问聚集类对象元素的方法。 具体代码实例可以参考迭代器模式 感谢参考： Decorator Facade Strategy 模板模式|菜鸟教程 迭代器模式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的Dispatch(分派)和Binding(绑定)]]></title>
    <url>%2F2018%2F06%2F18%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84Dispatch(%E5%88%86%E6%B4%BE)%E5%92%8CBinding(%E7%BB%91%E5%AE%9A)%2F</url>
    <content type="text"><![CDATA[Java中，绑定是指将方法名和具体方法绑定的过程。 而分派是在运行阶段，对已经绑定好的方法实行分配，决定该调用哪个方法。 Binding：绑定绑定可以分为前期绑定和后期绑定 前期/静态绑定 Java中的static，final，private的方法属于前期绑定。需要注意的是，Overload是静态绑定的。静态绑定在编译阶段完成。 后期/动态绑定 对Override的方法进行绑定，在运行时根据具体对象的类型进行绑定。 编译阶段，编译器还不知道对象的具体类型（例如不知道该对象调用子类的方法还是父类的方法）。 以父类型与子类型的转换为例，动态绑定大致过程如下： 编译器列出对象可能的所有方法表（父类+子类等） 运行时，匹配方法。 Dispatch：分派先绑定，后分派。分派决定在执行阶段执行哪一段代码。 静态分派： 若绑定是确定的，一一对应，那么执行静态分派，在编译阶段即可执行。 动态分派： 方法绑定了多段代码，在运行阶段根据具体类型的对象决定执行哪段代码， 在运行阶段执行。 Overload：提前绑定+动态分配 Override：延迟绑定+动态分配 所以动态分配不一定是延迟绑定，但延迟绑定一定意味着动态分配。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几个Lab过程中的bug]]></title>
    <url>%2F2018%2F06%2F03%2F%E8%AE%B0%E5%87%A0%E4%B8%AALab%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[写在前面Lab3-Lab5终于告一段落，持续了很久的实验，Lab3完成了程序的功能，Lab4补充功能并完成健壮性检查，Lab5主要进行I/O策略的优化，并分析程序运行情况。从实践学习Java的过程，会踩一些没有经验的坑，也是提升Java编程水平的过程。仅仅记录几个这个阶段的我学习过程中的bug，Java初学者，不正确的地方望指正。 1. 类内实例化自身具体怎么萌生这个神奇的想法我也无从考据了T_T……我只知道后来一直在为自己曾经的脑洞买单T_T 看一看这个bug： 123public class GraphPoet extends ConcreteGraph &#123; private GraphPoet graph = new GraphPoet();&#125; 这么搞的下场是Stack overflow，冷静分析一下，当一个类存储在栈上，相应的存储他的成员，但存储成员时，又实例化了一个新的“自己”，如此反复，栈空间耗尽，车祸现场。 debug！ 123public class GraphPoet extends ConcreteGraph &#123; private static GraphPoet graph = new GraphPoet();&#125; 对于当时的实验情况，加上关键字static就解决了栈溢出的问题，static是全局变量，当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例共用同一个static变量。所以在类的初始化时就创建了graph，实例化时则不再重复创建。 上述写法其实是不成熟的，当时对概念不够理解。后来发现对“静态变量“的使用是有所考究的，以下场景可以考虑使用静态变量： 变量所包含的对象体积较大，占用内存较多。 变量所包含的对象生命周期较长。 变量所包含的对象数据稳定。 该类的对象实例有对该变量所包含的对象的共享需求。 2.单例模式为什么说之前的代码是不成熟的，创建了一个static全局变量，全局变量可以直接通过类名调用，然而我却加上了private，Lab5思考到这个问题后，发现单例模式可以很好的应用在我的程序，满足需求，节省程序空间。 12345678public class GraphPoet extends ConcreteGraph &#123; private static final GraphPoet graph = new GraphPoet(); private GraphPoet() &#123;&#125; public static GraphPoet getInstance() &#123; return graph; &#125; 3.Junit的测试顺序Junit的测试函数的执行顺序是不确定的，符合单元测试的思想。 Junit 4.11里增加了指定测试方法执行顺序的特性 测试类的执行顺序可通过对测试类添加注解 “@FixMethodOrder(value)” 来指定,其中value 为执行顺序 三种执行顺序：默认MethodSorters.DEFAULT，按方法名MethodSorters.NAME_ASCENDING，按JVM返回的顺序MethodSorters.JVM. *当没有指定任何顺序时，按默认来执行 ，多次执行发现打印顺序不一样，下面是测试情况： 按方法名升序执行，可以按照指定顺序执行： 按照JVM的返回顺序，顺序可能会不同。 以上，1/bugs，希望成为垫脚石T_T]]></content>
  </entry>
  <entry>
    <title><![CDATA[重写equals方法]]></title>
    <url>%2F2018%2F04%2F03%2Ftime-%202018-4-3%2F</url>
    <content type="text"><![CDATA[Override equals()虽然Object是一个具体类，但它有一些非final的方法是被设计成override的，必要的时候，我们需要按照约定覆盖它们，适用于所有的类，本文介绍如何覆盖equals方法。 什么时候需要覆盖equals方法？首先我们得先明白，未被覆盖的equals方法比较的是什么。未覆盖的equals方法比较的是两个对象是否引用同一块内存，如果是则返回true。往往我们有自己的“逻辑相等”概念去判断两个对象是否相同，这时！我们需要重写equals方法。 如何覆盖equals方法？当我们设计自己的“等价概念”时，是要遵守通用约定的，以下选自Object的规范： 自反性(reflexive)：对于任何非null的引用值x, x.equals(x)必须返回true。 对称性(symmetric)：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。 传递性(transitive)：对于任何非null的引用值x，y和z，如果x.equals(y)返回true,并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。 一致性(consistent)：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致的返回true，或者false。 对于然和非null的引用值x，x.equals(null)必须返回false。 在MIT-6.031-15的讲义中，看个小例子：1234567public class Duration &#123; ... // Problematic definition of equals() public boolean equals(Duration that) &#123; return this.getLength() == that.getLength(); &#125;&#125; 这样重写equals方法后，我们调用一段客户端代码发现：12345Duration d1 = new Duration (1, 2);Duration d2 = new Duration (1, 2);Object o2 = d2;d1.equals(d2) → trued1.equals(o2) → false 即使o2和d2指向同一个引用，但结果却不同。这是因为Duration类里对equals方法进行了overload并不是override正确override的方式是：123456@Overridepublic boolean equals (Object thatObject) &#123; if (!(thatObject instanceof Duration)) return false; Duration thatDuration = (Duration) thatObject; return this.getLength() == thatDuration.getLength();&#125; 大致按照这个框架，我们可以覆盖equals方法，然后检查它是否满足约定。 强调一下，instanceof关键字的作用是比较一个对象是否是一个类的实例。使用instanceof是一种动态类型检查，相较之下我们更喜欢静态的。除了在实现重写equals方法中，其他任何地方是禁止使用instanceof的。 重写hashCode方法覆盖了equals方法意味着必须要覆盖hashCode方法。如果不这样的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这些集合包括HashMap，HashSet，Hashtable。 我们要设计一个好的散列函数，让它为不相等的对象产生不相等的散列码。不求完美，我们应该尽量去接近理想状态。Effective Java介绍了一套如何设计散列函数的思想，参照《Effective Java》第9条可以了解。 参考资料：Effective Java：第8条，第9条MIT-6.031：Reading 15: EqualityObject规范]]></content>
  </entry>
  <entry>
    <title><![CDATA[MIT-6.031-13]]></title>
    <url>%2F2018%2F03%2F23%2FMIT6.031%2013%2F</url>
    <content type="text"><![CDATA[Reading 13:Abstraction Functions &amp; Rep Invariants关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。Reading 13:Abstraction Functions &amp; Rep Invariants Invariants一个好的抽象数据类型(以下简称ADT)，很重要的一点是，它要保护自己的不变性。注意，优秀ADT是自我保护不变性的，而不是依赖规范客户的行为。其实，当ADT可以自我保护的时候，程序员的工作也就更简化了，你可能调试更少的bug等等。 Immutability来，先看看不变性(immutable) 123456789101112131415161718192021/*** This immutable data type represents a tweet from Twitter.*/public class Tweet &#123; public String author; public String text; public Date timestamp; /** * Make a Tweet. * @param author Twitter user who wrote the tweet * @param text text of the tweet * @param timestamp date/time when the tweet was sent */ public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = timestamp; &#125;&#125; 一个问题，我们怎么保证一旦创建推特，作者，内容就不能改变？上面的示例，我们可以发现，用户可以访问所有内容，而并不能保证作者和内容不能修改的条件。 1234Tweet t = new Tweet("justinbieber", "Thanks to all those beliebers out there inspiring me every day", new Date());t.author = "rbmllr"; 可以这样直接修改作者，所以这是一个表示性暴露(representation exposure)的例子，意味着类外能直接修改类内的表示。改一下： 1234567891011121314151617181920212223242526public class Tweet &#123; private final String author; private final String text; private final Date timestamp; public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = timestamp; &#125; /** @return Twitter user who wrote the tweet */ public String getAuthor() &#123; return author; &#125; /** @return text of the tweet */ public String getText() &#123; return text; &#125; /** @return date/time when the tweet was sent */ public Date getTimestamp()&#123; return timestamp; &#125; private表示了属性只能在类内访问，public则表示可以在类外访问。final关键字则帮助我们确保了属性的不变性，final修饰的对象，一旦初始化后，值不能改变。但，其实依旧存在表示泄露(rep exposure), 我们来看一下如果用户这样操作： 123456/** @return a tweet that retweets t, one hour later*/public static Tweet retweetLater(Tweet t) &#123; Date d = t.getTimestamp(); d.setHours(d.getHours()+1); return new Tweet("rbmllr", t.getText(), d);&#125; 该方法retweetLater的功能是，get一条推特，1小时候用户重新发一条一样的推特(转发功能)。bug来了，Date是可变数据类型(mutable)，getTimestamp方法返回t的时间，类型是Date，且令d = t.getTimestamp(),这导致d指向了t的timestamp。然后d利用setHours改变了自己的时间，其实！这也就改变了t的时间，因为t和d都引用了同一块内存空间，看个快照会清楚一些：辛辛苦苦保护的属性，还是被破坏了……冷静分析一下问题所在，Tweet类泄露的可变的(mutable)的引用给客户。我们可以用防御式复制(defensive copying)来debug：复制可变数据(mutable)类型的对象，防止数据暴露给客户： 123public Date getTimestamp() &#123; return new Date(timestamp.getTime());&#125; 注意到没，返回的是一个新的Date，是不同于原来的timestamp的新的引用。可变数据类型(mutable)通常有一个复制构造函数(copy constructor)，允许你创建新实例复制已有实例的值。举个例子，StringBuilder的copy constructor需要一个String类型的数据。另一种复制一个可变数据类型的方法是clone()。 虽然我们采用了防御式复制，但我们还没完全解决表示性泄露(rep exposure)。看看下面这个用户代码： 12345678910/** @return a list of 24 inspiring tweets, one per hour today */public static List&lt;Tweet&gt; tweetEveryHourToday () &#123; List&lt;Tweet&gt; list = new ArrayList&lt;Tweet&gt;(); Date date = new Date(); for (int i = 0; i &lt; 24; i++) &#123; date.setHours(i); list.add(new Tweet("rbmllr", "keep it up! you can do it", date)); &#125; return list;&#125; 这段代码每小时创建一条tweet，但其实所有24条tweet的时间都是最后一条的时间，我们来看个快照图就很清楚：每条tweet引用的都是同一个date。我们可以改进一下之前的防御性复制，这样修改构造函数： 12345public Tweet(String author, String text, Date timestamp) &#123; this.author = author; this.text = text; this.timestamp = new Date(timestamp.getTime());&#125; 一般来说，程序员应该仔细检查变量类型和返回的ADT类型。如果有可变(mutable)数据类型的，确保你的代码没有暴露它们的引用，防止rep exposure。 哎？你或许觉得这有点资源浪费？为什么非要复制啊？为什么不能直接在spec里写明白？像这样： 123456789/*Make a Tweet.- @param author Twitter user who wrote the tweet- @param text text of the tweet - @param timestamp date/time when the tweet was sent. Caller must never - mutate this Date object again!*/public Tweet(String author, String text, Date timestamp) &#123; 这种方法在“某些时候”是可行的，比如当可变数据类型过大的时候，防御性复制就很低效了。 虽然防御性复制损失空间，但总体来说很必要。为什么？我认为这是在赋予程序一种避免bug的的能力。所以ADT保护自己不变性，保护表示性不泄露，这是它的基础能力。 让你的ADT成为一个优秀的ADT吧！ 另一种是用不可变数据类型(immutable)，比如我们可以采用不可变的时间对象java.time.ZonedDateTime替换可变的java.util.Date。 Immutable wrappers around mutable data typesJava的集合类提供了一个有趣的折中：不可变包装器(immutable wrappers)////历史遗留问题////// Rep invariant and abstraction function我们设计ADT时，可以考虑“两种值的空间”的关系。两种值的空间，喵喵喵？介绍一下它们：1.暴露给客户的值的组成空间(rep values)：这个空间由实例化后的值组成。简言之，你的ADT会实例成一个对象吧？但更常见的是，我们经常需要一个小型的网络对象，所以这个值，是非常复杂的。2.抽象值空间(abstract values)：由你设计的ADT支持的抽象数据类型组成。比如，一个无边界整型的抽象值空间可能是数学上的整数，实际上，它被实现为一个基本类型的整型数组(有界的)。 现在，假设，我们采用一个字符串代表一组字符： 1234public class CharSet &#123; private String s; ...&#125; R(rep values)包含了字符串，A(abstract values)包含了字符的数学集合。 A中每个值都能在R中找到原象，即这个映射关系是满射的。 A中一些值可以在R中找到不止一个原象。 R中不是所有的值都有映射。满射，不一定单射，所以不一定双射。例如“abbc”是非法字符串，因为我们定义不能内含重复字符。 我们为了刻画这两个空间的关系，给出两个定义：1.AF：一个抽象函数映射使得R-&gt;A AF: R-&gt;A 2.RI：个人理解为一个衡量R是否合格的指标 RI: R-&gt;boolean RI可以被形容为一个集合，是AF成立的子集。 我们应该在代码中记录AF和RI，紧挨着你设计的数据表示(rep)，比如： 12345678public class CharSet &#123; private String s; // Rep invariant: // s contains no repeated characters // Abstraction Function: // represents the set of characters found in s ...&#125;]]></content>
      <categories>
        <category>MIT</category>
      </categories>
      <tags>
        <tag>MIT讲义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT-6.031-07]]></title>
    <url>%2F2018%2F03%2F20%2FMIT6.031%2007%2F</url>
    <content type="text"><![CDATA[Reading 7:Designing Specifications关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。MIT-6.031-07 Reading 7 : Designing Specifications Introduction本文主要从不同的specs实例对比中，介绍如何设计specs。 确定性(deterministic)：规格是否定义明确？例如一个输入对应一个输出，还是可以有多种可能。 说明性()：规格是否说明“到位”？例如是否说明了如何输入，或者对输出结果的要求。 强度：是否有足够的数据集支撑？例如一个合理的小数集，或者大集合（显然两者起到不同的作用）。 上述三个维度有时不可兼得，则我们根据实际权衡，折中达到最优。 Deterministic VS underdetermined specsstatic int findFirst(int[] arr, int val) { for (int i = 0; i &lt; arr.length; i++) { if (arr[i] == val) return i; } return arr.length; } static int findLast(int[] arr, int val) { for (int i = arr.length - 1 ; i &gt;= 0; i--) { if (arr[i] == val) return i; } return -1; } 上面是两个方法,First和Last只是为了区分它们的实现方式。在实际代码中，它们都是find方法。再来看一下find的规格(specification): static int findExactlyOne(int[] arr, int val) requires: val occurs exactly once in arr effects: returns index i such that arr[i] = val 这个规格findExactlyOne是确定(deterministic)的：即当输入满足前置条件时，findFirst和findLast方法都可以正确输出，即达成后置条件。 这里，还有另一个规格findOneOrMore,AnyIndex： static int findOneOrMore,AnyIndex(int[] arr, int val) requires: val occurs in arr effects: returns index i such that arr[i] = val 它不同于findExactlyOne的是，前置条件变成了val在arr中出现即可，这样弱化了前置条件，导致这个规格是不确定的。若val多次出现，则effects并没有说明返回的index是哪一个，它是不确定的。 注意，此处的不确定并不是传统意义的。费确定性代码指的是，给它相同的输入，可能会有不同的输出。为了避免混淆，我们把这种不确定性称为 underdetermined。 Declarative VS operational specs大致可以分成两种：Declarative spec和Operational spec。声明性的(Declarative spec)：不会描述细节和中间过程。反而注重描述输出结果的属性，与初始输入的关系。操作性的(Operational spec)：描述了方法执行的步骤，细节等，例如伪代码。 对于spec，我们更青睐Declarative spec ,因为它简短，易于理解，且更重要的是，它不会暴露具体实现的细节给客户。 但是，有时程序员会在spec里写操作性的实现细节利于维护者维护。注意，这不是一个好习惯！这可以在方法内部进行说明，但一定不要让它出现在spec里。 举个例子吧： static String join(String delimiter, String[] elements) effects: append together the strings in elements, but at each step, if there are more elements left, insert delimiter 这是一个操作性的(operational)spec。修改它，让它变得declarative，可以这样： effects: returns concatenation of elements in order, with delimiter inserted between each pair of adjacent elements 更改之后，仅仅说明了属性，没有暴露具体实现。 Stronger VS weaker specs现在我们来考虑这种情况：假设你想要改变一个方法，无视方法的具体实现和spec本身。现在已经有客户采用已有的spec了。是新写一个spec呢？还是用原来的就可以？以上得出，我们需要一个标准来判断两个spec的强弱。S2强于S1，则： S2的前置条件弱于S1 S2的后置条件强于S1 简言之，想要加强一个spec，弱化前置，强化后置。 为什么要强化spec？取代原有spec。发现了没，这种“强化升级”，其实也提升了用户体验。减少对用户的需求，却增加了“回报”，让用户放心。 来，再看看我们之前提到的specs： static int findExactlyOne(int[] a, int val) requires: val occurs exactly once in a effects: returns index i such that a[i] = val 弱化前置条件： static int findOneOrMore,AnyIndex(int[] a, int val) requires: val occurs at least once in a effects: returns index i such that a[i] = val 强化后置条件： static int findOneOrMore,FirstIndex(int[] a, int val) requires: val occurs at least once in a effects: returns lowest index i such that a[i] = val 再强化后置条件： static int findCanBeMissing(int[] a, int val) requires: nothing effects: returns index i such that a[i] = val,or -1 if no such i Diagramming specification我们可以利用图形表示spec，往往更清晰更直观。 假设Java世界是一个无限空间，我们用一个点代表一个方法，就像这样： spec是有一个合理范围的，对于能实现该spec的方法，我们把它放在范围内，反之则在范围外。findFirst和findLast都满足findOneOrMore,AnyIndex，所以在范围内： 再后来我们做了什么事情呢？我们强化了findOneOrMore,AnyIndex，问题来了，怎么表示？1.强化后置：这意味着程序员需要对输出更严格，这导致有的方法之前满足findOneOrMore,AnyIndex(S1)，但现在不满足findOneOrMore,FirstIndex(S2)，那它在S2外，S1里。2.弱化前置：这意味着要处理更多的输入情况。下图中，S2强于S1，findLast在S2范围外，findFirst满足S2，在范围内。]]></content>
      <categories>
        <category>MIT</category>
      </categories>
      <tags>
        <tag>MIT讲义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven初步学习]]></title>
    <url>%2F2018%2F03%2F11%2FMaven%2F</url>
    <content type="text"><![CDATA[初次了解软件构造和maven，仅记录学习maven的过程。本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。 1. Maven？ Maven主要服务于基于Java平台的项目构建，项目信息管理。通俗一点说，Maven不仅是一个构建工具，它是一个自动化的构建工具。在软件开发中，其实是有专人负责去构建的(构建是一个过程，包含编译，测试，打包，部署等)，但Maven所做的是把构建的一系列工作像流水线一样自动完成。 2.Maven使用入门 POM.xmlPOM(Project Object Model,项目对象模型)，顾名思义，它定义了项目的基本信息，描述项目如何构建等。举一个简单的例子： 123456789&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt; &lt;artifactId&gt;Hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;project&gt; 可以发现代码中定义了groupId,artifactId,version：groupId一般是组织或者公司相关artifactId是唯一的，如上面的例子中是Hello-worldversion指定版本，SNAPSHOT意为快照，表示当前版本还在开发中，不稳定。 POM.xml可以说是整个Maven项目的核心，我们只需要修改POM.xml即可以达到不同的构建目标，声明依赖关系等。 Maven的文件夹默认格式Maven工程是自动化的，所以我们需要按照约定创建目录，这样Maven才能在自动化的构建过程中找到源文件，通常约定的结构是这样的：|—src 源码|—|—main 存放主程序|—|—|—java 存放Java源文件|—|—|—resources 存放框架或其他工具的配置文件|—|—test 存放测试程序|—|—|—java 存放Java测试的源文件|—|—|—resources 存放测试的配置文件|—POM.xml Maven工程的核心配置文件 手工生成上述目录可以说是很麻烦了，Maven解决了这个问题，提供Archetype帮助我们快速勾勒出项目骨架。 Maven3环境下，执行： mvn archetype:generate 然后会看到很多Archetype可供我们选择，这帮助我们快速构建项目骨架，节省了很多时间。 Eclipse下开发Maven工程：会自动生成上述文件目录，我们只需要按约定放好源文件即可。 Maven的构建过程概述 我们先看几个主要的Maven命令： mvn clean compile //编译 mvn clean test //测试 mvn clean package //打包 mvn clean install //安装项目输出的jar包到本地仓库中 先解释一下命令的含义，clean告诉Maven清理输出目录target/(默认情况下，Maven构建的所有输出都在该目录中)，compile告诉Maven编译项目主代码，项目主代码将会编译输出到target/classes目录下。 上述命令其实是对应了Maven的插件以及插件目标，clean是clean插件的目标，test是test插件 的目标。 编译—-&gt;测试—-&gt;打包—-&gt;安装 执行test之前会执行compile，同样执行package之前会执行test。 3.Maven坐标和依赖 坐标这个概念始于平面几何，它可以用来唯一的标识一个元素。《Maven实战中》里，很生动的将其描述为： Maven给Java类库(例如jar文件)世界引入了经纬，让他们变得有秩序，于是我们可以借助它来有序的管理依赖，轻松的解决那些繁琐的依赖问题。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-melody v1.5 supports iframe & slides]]></title>
    <url>%2F2018%2F03%2F06%2Fiframe%2F</url>
    <content type="text"></content>
  </entry>
</search>
