<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chan</title>
  
  <subtitle>尝试积极更新</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://libchan.github.io/"/>
  <updated>2018-03-20T13:52:47.629Z</updated>
  <id>http://libchan.github.io/</id>
  
  <author>
    <name>Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://libchan.github.io/2018/03/20/MIT6.031%2007/"/>
    <id>http://libchan.github.io/2018/03/20/MIT6.031 07/</id>
    <published>2018-03-20T09:33:10.888Z</published>
    <updated>2018-03-20T13:52:47.629Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: MIT6.031讲义 07<br>time: </p><h2 id="categories-MIT"><a href="#categories-MIT" class="headerlink" title="categories: MIT"></a>categories: MIT</h2><h1 id="Reading-7-Designing-Specifications"><a href="#Reading-7-Designing-Specifications" class="headerlink" title="Reading 7:Designing Specifications"></a>Reading 7:Designing Specifications</h1><p>关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。<br><a href="http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/" title="MIT6.031-Reading 7：Designing Specification" target="_blank" rel="noopener">http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/</a><br><a id="more"></a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本文主要从不同的specs实例对比中，介绍如何设计specs。</p><ol><li>确定性(deterministic)：规格是否定义明确？例如一个输入对应一个输出，还是可以有多种可能。</li><li>说明性()：规格是否说明“到位”？例如是否说明了如何输入，或者对输出结果的要求。</li><li>强度：是否有足够的数据集支撑？例如一个合理的小数集，或者大集合（显然两者起到不同的作用）。   </li></ol><p>上述三个维度有时不可兼得，则我们根据实际权衡，折中达到最优。</p><h2 id="Deterministic-VS-underdetermined-specs"><a href="#Deterministic-VS-underdetermined-specs" class="headerlink" title="Deterministic VS underdetermined specs"></a>Deterministic VS underdetermined specs</h2><pre><code>static int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}                   static int findLast(int[] arr, int val) {    for (int i = arr.length - 1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}</code></pre><p>上面是两个方法,First和Last只是为了区分它们的实现方式。在实际代码中，它们都是<code>find</code>方法。<br>再来看一下<code>find</code>的规格(specification):</p><pre><code>static int findExactlyOne(int[] arr, int val)requires: val occurs exactly once in arreffects:  returns index i such that arr[i] = val </code></pre><p><strong>这个规格<code>findExactlyOne</code>是确定(deterministic)的</strong>：即当输入满足前置条件时，<code>findFirst</code>和<code>findLast</code>方法都可以正确输出，即达成后置条件。</p><p>这里，还有另一个规格<code>findOneOrMore,AnyIndex</code>：</p><pre><code>static int findOneOrMore,AnyIndex(int[] arr, int val)requires: val occurs in arreffects:  returns index i such that arr[i] = val</code></pre><p>它不同于<code>findExactlyOne</code>的是，前置条件变成了val在arr中出现即可，这样弱化了前置条件，导致这个规格是不确定的。若val多次出现，则effects并没有说明返回的index是哪一个，<strong>它是不确定的</strong>。</p><p>注意，此处的<strong>不确定</strong>并不是传统意义的。费确定性代码指的是，给它相同的输入，可能会有不同的输出。<br>为了避免混淆，我们把这种不确定性称为<strong> underdetermined</strong>。</p><h2 id="Declarative-VS-operational-specs"><a href="#Declarative-VS-operational-specs" class="headerlink" title="Declarative VS operational specs"></a>Declarative VS operational specs</h2><p>大致可以分成两种：<code>Declarative spec</code>和<code>Operational spec</code>。<br>声明性的<code>(Declarative spec)</code>：不会描述细节和中间过程。反而注重描述输出结果的属性，与初始输入的关系。<br>操作性的<code>(Operational spec)</code>：描述了方法执行的步骤，细节等，例如伪代码。</p><p><strong> 对于spec，我们更青睐<code>Declarative spec</code> ,因为它简短，易于理解，且更重要的是，它不会暴露具体实现的细节给客户</strong>。</p><p>但是，有时程序员会在spec里写操作性的实现细节利于维护者维护。注意，这不是一个好习惯！这可以在方法内部进行说明，但一定不要让它出现在spec里。</p><p>举个例子吧：</p><pre><code>static String join(String delimiter, String[] elements)effects: append together the strings in elements, but at each step,         if there are more elements left, insert delimiter</code></pre><p>这是一个操作性的(operational)spec。<br>修改它，让它变得declarative，可以这样：</p><pre><code>effects: returns concatenation of elements in order,          with delimiter inserted between each pair of adjacent elements</code></pre><p>更改之后，仅仅说明了属性，没有暴露具体实现。</p><h2 id="Stronger-VS-weaker-specs"><a href="#Stronger-VS-weaker-specs" class="headerlink" title="Stronger VS weaker specs"></a>Stronger VS weaker specs</h2><p>现在我们来考虑这种情况：假设你想要改变一个方法，无视方法的具体实现和spec本身。现在已经有客户采用已有的spec了。是新写一个spec呢？还是用原来的就可以？<br>以上得出，我们需要一个标准来判断两个spec的强弱。S2强于S1，则：</p><ul><li>S2的前置条件弱于S1</li><li>S2的后置条件强于S1</li></ul><blockquote><p>简言之，想要加强一个spec，<strong>弱化前置，强化后置</strong>。</p></blockquote><p>为什么要强化spec？取代原有spec。<br>发现了没，这种“强化升级”，其实也提升了用户体验。减少对用户的需求，却增加了“回报”，让用户放心。</p><p>来，再看看我们之前提到的specs：</p><pre><code>static int findExactlyOne(int[] a, int val)requires: val occurs exactly once in aeffects:  returns index i such that a[i] = val</code></pre><p>弱化前置条件：</p><pre><code>static int findOneOrMore,AnyIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns index i such that a[i] = val</code></pre><p>强化后置条件：</p><pre><code>static int findOneOrMore,FirstIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns lowest index i such that a[i] = val</code></pre><p>再强化后置条件：</p><pre><code>static int findCanBeMissing(int[] a, int val)requires: nothingeffects:  returns index i such that a[i] = val,or -1 if no such i</code></pre><h2 id="Diagramming-specification"><a href="#Diagramming-specification" class="headerlink" title="Diagramming specification"></a>Diagramming specification</h2><p>我们可以利用图形表示spec，往往更清晰更直观。</p><ul><li>假设Java世界是一个无限空间，我们用一个点代表一个方法，就像这样：<br><img src="https://i.imgur.com/NLsYCzi.jpg" alt=""></li></ul><ul><li><p>spec是有一个合理范围的，对于能实现该spec的方法，我们把它放在范围内，反之则在范围外。<br><code>findFirst</code>和<code>findLast</code>都满足<code>findOneOrMore,AnyIndex</code>，所以在范围内：<br><img src="https://i.imgur.com/8caEGzH.jpg" alt=""></p></li><li><p>再后来我们做了什么事情呢？我们强化了<code>findOneOrMore,AnyIndex</code>，问题来了，怎么表示？<br>1.强化后置：<br>这意味着程序员需要对输出更严格，这导致有的方法之前满足<code>findOneOrMore,AnyIndex</code>(S1)，但现在不满足<code>findOneOrMore,FirstIndex</code>(S2)，那它在S2外，S1里。<br>2.弱化前置：<br>这意味着要处理更多的输入情况。<br>下图中，S2强于S1，<code>findLast</code>在S2范围外，<code>findFirst</code>满足S2，在范围内。<br><img src="https://i.imgur.com/9qoCpZX.jpg" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: MIT6.031讲义 07&lt;br&gt;time: &lt;/p&gt;
&lt;h2 id=&quot;categories-MIT&quot;&gt;&lt;a href=&quot;#categories-MIT&quot; class=&quot;headerlink&quot; title=&quot;categories: MIT&quot;&gt;&lt;/a&gt;categories: MIT&lt;/h2&gt;&lt;h1 id=&quot;Reading-7-Designing-Specifications&quot;&gt;&lt;a href=&quot;#Reading-7-Designing-Specifications&quot; class=&quot;headerlink&quot; title=&quot;Reading 7:Designing Specifications&quot;&gt;&lt;/a&gt;Reading 7:Designing Specifications&lt;/h1&gt;&lt;p&gt;关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。&lt;br&gt;&lt;a href=&quot;http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/&quot; title=&quot;MIT6.031-Reading 7：Designing Specification&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Maven初步学习</title>
    <link href="http://libchan.github.io/2018/03/11/Maven/"/>
    <id>http://libchan.github.io/2018/03/11/Maven/</id>
    <published>2018-03-11T09:57:42.384Z</published>
    <updated>2018-03-12T15:51:02.436Z</updated>
    
    <content type="html"><![CDATA[<p>初次了解软件构造和maven，仅记录学习maven的过程。<br>本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。<br><a id="more"></a></p><p><strong>1. Maven？</strong></p><p>Maven主要服务于基于Java平台的项目构建，项目信息管理。通俗一点说，Maven不仅是一个构建工具，它是一个<strong>自动化的构建工具</strong>。在软件开发中，其实是有专人负责去构建的(构建是一个过程，包含编译，测试，打包，部署等)，但Maven所做的是把构建的一系列工作<strong>像流水线一样自动完成</strong>。</p><p><strong>2.Maven使用入门</strong></p><ul><li><strong>POM.xml</strong><br>POM(Project Object Model,项目对象模型)，顾名思义，它<strong>定义了项目的基本信息，描述项目如何构建等</strong>。举一个简单的例子： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Hello-world&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>可以发现代码中定义了groupId,artifactId,version：<br>groupId一般是组织或者公司相关<br>artifactId是唯一的，如上面的例子中是Hello-world<br>version指定版本，SNAPSHOT意为快照，表示当前版本还在开发中，不稳定。</p><blockquote><p><strong>POM.xml可以说是整个Maven项目的核心，我们只需要修改POM.xml即可以达到不同的构建目标，声明依赖关系等。</strong></p></blockquote><ul><li><p><strong>Maven的文件夹默认格式</strong><br>Maven工程是自动化的，所以我们需要<strong>按照约定创建目录</strong>，这样Maven才能在自动化的构建过程中找到源文件，通常约定的结构是这样的：<br><strong><br>|—src                源码<br>|—|—main            存放主程序<br>|—|—|—java        存放Java源文件<br>|—|—|—resources    存放框架或其他工具的配置文件<br>|—|—test            存放测试程序<br>|—|—|—java        存放Java测试的源文件<br>|—|—|—resources    存放测试的配置文件<br>|—POM.xml                Maven工程的核心配置文件</strong></p><p>  手工生成上述目录可以说是很麻烦了，Maven解决了这个问题，提供<strong>Archetype</strong>帮助我们快速勾勒出项目骨架。<br>  Maven3环境下，执行：<br>  mvn archetype:generate<br>  然后会看到很多Archetype可供我们选择，这帮助我们快速构建项目骨架，节省了很多时间。<br>  Eclipse下开发Maven工程：会自动生成上述文件目录，我们只需要按约定放好源文件即可。</p></li></ul><ul><li><p><strong>Maven的构建过程概述</strong></p><p>  我们先看几个主要的Maven命令：<br>  mvn clean compile     //编译<br>  mvn clean test        //测试<br>  mvn clean package    //打包<br>  mvn clean install    //安装项目输出的jar包到本地仓库中</p><p>  先解释一下命令的含义，clean告诉Maven清理输出目录target/(默认情况下，Maven构建的所有输出都在该目录中)，compile告诉Maven编译项目主代码，项目主代码将会编译输出到target/classes目录下。<br>  上述命令其实是对应了Maven的插件以及插件目标，clean是clean插件的目标，test是test插件    的目标。</p><p>  <strong>编译—-&gt;测试—-&gt;打包—-&gt;安装</strong><br>  执行test之前会执行compile，同样执行package之前会执行test。</p></li></ul><p><strong>3.Maven坐标和依赖</strong>  </p><p>坐标这个概念始于平面几何，它可以用来唯一的标识一个元素。<br>《Maven实战中》里，很生动的将其描述为：</p><blockquote><p>Maven给Java类库(例如jar文件)世界引入了经纬，让他们变得有秩序，于是我们可以借助它来有序的管理依赖，轻松的解决那些繁琐的依赖问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初次了解软件构造和maven，仅记录学习maven的过程。&lt;br&gt;本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。&lt;br&gt;
    
    </summary>
    
      <category term="tool" scheme="http://libchan.github.io/categories/tool/"/>
    
    
      <category term="maven" scheme="http://libchan.github.io/tags/maven/"/>
    
  </entry>
  
</feed>
