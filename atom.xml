<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chan</title>
  
  <subtitle>尝试积极更新</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://libchan.github.io/"/>
  <updated>2018-03-28T02:30:02.502Z</updated>
  <id>http://libchan.github.io/</id>
  
  <author>
    <name>Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT-6.031-13</title>
    <link href="http://libchan.github.io/2018/03/23/MIT6.031%2013/"/>
    <id>http://libchan.github.io/2018/03/23/MIT6.031 13/</id>
    <published>2018-03-23T03:45:24.397Z</published>
    <updated>2018-03-28T02:30:02.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reading-13-Abstraction-Functions-amp-Rep-Invariants"><a href="#Reading-13-Abstraction-Functions-amp-Rep-Invariants" class="headerlink" title="Reading 13:Abstraction Functions &amp; Rep Invariants"></a>Reading 13:Abstraction Functions &amp; Rep Invariants</h1><p>关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。<br><a href="http://web.mit.edu/6.031/www/sp17/classes/13-abstraction-functions-rep-invariants/#reading_13_abstraction_functions_rep_invariants" target="_blank" rel="noopener">Reading 13:Abstraction Functions &amp; Rep Invariants</a><br><a id="more"></a></p><h2 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h2><p>一个好的抽象数据类型(以下简称ADT)，很重要的一点是，它要<strong>保护自己的不变性</strong>。注意，优秀ADT是自我保护不变性的，而不是依赖规范客户的行为。<br>其实，当ADT可以自我保护的时候，程序员的工作也就更简化了，你可能调试更少的bug等等。</p><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>来，先看看不变性(immutable)</p><pre><code>/*** This immutable data type represents a tweet from Twitter.*/public class Tweet {    public String author;    public String text;    public Date timestamp;    /**     * Make a Tweet.     * @param author    Twitter user who wrote the tweet     * @param text      text of the tweet     * @param timestamp date/time when the tweet was sent */    public Tweet(String author, String text, Date timestamp) {        this.author = author;        this.text = text;        this.timestamp = timestamp;    }}</code></pre><p>一个问题，我们怎么保证一旦创建推特，作者，内容就不能改变？<br>上面的示例，我们可以发现，用户可以访问所有内容，而并不能保证作者和内容不能修改的条件。</p><pre><code>Tweet t = new Tweet(&quot;justinbieber&quot;,                     &quot;Thanks to all those beliebers out there inspiring me every day&quot;,                     new Date());t.author = &quot;rbmllr&quot;;</code></pre><p>可以这样直接修改作者，所以这是一个<strong>表示性暴露(representation exposure)</strong>的例子，意味着类外能直接修改类内的表示。<br>改一下：</p><pre><code>public class Tweet {    private final String author;    private final String text;    private final Date timestamp;    public Tweet(String author, String text, Date timestamp) {        this.author = author;        this.text = text;        this.timestamp = timestamp;    }    /** @return Twitter user who wrote the tweet */    public String getAuthor() {        return author;    }    /** @return text of the tweet */    public String getText() {        return text;    }    /** @return date/time when the tweet was sent */    public Date getTimestamp() {        return timestamp;    }}</code></pre><p><code>private</code>表示了属性只能在类内访问，<code>public</code>则表示可以在类外访问。<code>final</code>关键字则帮助我们确保了属性的不变性，<code>final</code>修饰的对象，一旦初始化后，值不能改变。<br>但，其实依旧存在表示泄露(rep exposure), 我们来看一下如果用户这样操作：</p><pre><code>/** @return a tweet that retweets t, one hour later*/public static Tweet retweetLater(Tweet t) {    Date d = t.getTimestamp();    d.setHours(d.getHours()+1);    return new Tweet(&quot;rbmllr&quot;, t.getText(), d);}</code></pre><p>该方法<code>retweetLater</code>的功能是，get一条推特，1小时候用户重新发一条一样的推特(转发功能)。<br>bug来了，Date是可变数据类型(mutable)，<code>getTimestamp</code>方法返回t的时间，类型是Date，且令d = t.getTimestamp(),这导致d指向了t的timestamp。然后d利用<code>setHours</code>改变了自己的时间，其实！这也就改变了t的时间，因为t和d都引用了同一块内存空间，看个快照会清楚一些：<br><img src="https://i.imgur.com/FpBVhxj.jpg" alt=""><br>辛辛苦苦保护的属性，还是被破坏了……<br>冷静分析一下问题所在，<code>Tweet</code>类泄露的可变的(mutable)的引用给客户。<br>我们可以用<strong>防御式复制(defensive copying)</strong>来debug：复制可变数据(mutable)类型的对象，防止数据暴露给客户：</p><pre><code>public Date getTimestamp() {    return new Date(timestamp.getTime());}</code></pre><p>注意到没，返回的是一个新的Date，是不同于原来的timestamp的新的引用。<br>可变数据类型(mutable)通常有一个复制构造函数(copy constructor)，允许你创建新实例复制已有实例的值。<br>举个例子，<code>StringBuilder</code>的copy constructor需要一个String类型的数据。另一种复制一个可变数据类型的方法是<code>clone()</code>。</p><p>虽然我们采用了防御式复制，但我们还没完全解决表示性泄露(rep exposure)。看看下面这个用户代码：</p><pre><code>/** @return a list of 24 inspiring tweets, one per hour today */public static List&lt;Tweet&gt; tweetEveryHourToday () {    List&lt;Tweet&gt; list = new ArrayList&lt;Tweet&gt;();     Date date = new Date();    for (int i = 0; i &lt; 24; i++) {        date.setHours(i);        list.add(new Tweet(&quot;rbmllr&quot;, &quot;keep it up! you can do it&quot;, date));    }     return list;}</code></pre><p>这段代码每小时创建一条tweet，但其实所有24条tweet的时间都是最后一条的时间，我们来看个快照图就很清楚：<br><img src="https://i.imgur.com/KndNmHD.jpg" alt=""><br>每条tweet引用的都是同一个date。<br>我们可以改进一下之前的防御性复制，这样修改构造函数：</p><pre><code>public Tweet(String author, String text, Date timestamp) {    this.author = author;    this.text = text;    this.timestamp = new Date(timestamp.getTime());}</code></pre><p>一般来说，程序员应该仔细检查变量类型和返回的ADT类型。如果有可变(mutable)数据类型的，确保你的代码没有暴露它们的引用，防止rep exposure。</p><p>哎？你或许觉得这有点资源浪费？为什么非要复制啊？为什么不能直接在spec里写明白？像这样：</p><pre><code>/** * Make a Tweet. * @param author    Twitter user who wrote the tweet * @param text      text of the tweet * @param timestamp date/time when the tweet was sent. Caller must never  *                   mutate this Date object again! */public Tweet(String author, String text, Date timestamp) {</code></pre><p>这种方法在“某些时候”是可行的，比如当可变数据类型过大的时候，防御性复制就很低效了。</p><p>虽然防御性复制损失空间，但总体来说很必要。为什么？我认为这是在赋予程序一种避免bug的的能力。所以ADT保护自己不变性，保护表示性不泄露，这是它的基础能力。</p><blockquote><p><strong>让你的ADT成为一个优秀的ADT吧！</strong></p></blockquote><p>另一种是用不可变数据类型(immutable)，比如我们可以采用不可变的时间对象<code>java.time.ZonedDateTime</code>替换可变的<code>java.util.Date</code>。</p><h3 id="Immutable-wrappers-around-mutable-data-types"><a href="#Immutable-wrappers-around-mutable-data-types" class="headerlink" title="Immutable wrappers around mutable data types"></a>Immutable wrappers around mutable data types</h3><p>Java的集合类提供了一个有趣的折中：<strong>不可变包装器(immutable wrappers)</strong><br>////历史遗留问题//////</p><h2 id="Rep-invariant-and-abstraction-function"><a href="#Rep-invariant-and-abstraction-function" class="headerlink" title="Rep invariant and abstraction function"></a>Rep invariant and abstraction function</h2><p>我们设计ADT时，可以考虑“两种值的空间”的关系。两种值的空间，喵喵喵？介绍一下它们：<br>1.暴露给客户的值的组成空间(rep values)：这个空间由实例化后的值组成。简言之，你的ADT会实例成一个对象吧？但更常见的是，我们经常需要一个小型的网络对象，所以这个值，是非常复杂的。<br>2.抽象值空间(abstract values)：由你设计的ADT支持的抽象数据类型组成。比如，一个无边界整型的抽象值空间可能是数学上的整数，实际上，它被实现为一个基本类型的整型数组(有界的)。</p><p>现在，假设，我们采用一个字符串代表一组字符：</p><pre><code>public class CharSet {    private String s;    ...}</code></pre><p><img src="https://i.imgur.com/BIfiPgk.jpg" alt=""><br>R(rep values)包含了字符串，A(abstract values)包含了字符的数学集合。</p><ul><li>A中每个值都能在R中找到原象，即这个映射关系是满射的。</li><li>A中一些值可以在R中找到不止一个原象。</li><li>R中不是所有的值都有映射。<br>满射，不一定单射，所以不一定双射。<br>例如“abbc”是非法字符串，因为我们定义不能内含重复字符。</li></ul><p>我们为了刻画这两个空间的关系，给出两个定义：<br>1.AF：一个抽象函数映射使得R-&gt;A</p><blockquote><p>AF: R-&gt;A</p></blockquote><p>2.RI：个人理解为一个衡量R是否合格的指标</p><blockquote><p>RI: R-&gt;boolean</p></blockquote><p>RI可以被形容为一个集合，是AF成立的子集。</p><p>我们应该在代码中记录AF和RI，紧挨着你设计的数据表示(rep)，比如：</p><pre><code>public class CharSet {    private String s;    // Rep invariant:    //    s contains no repeated characters    // Abstraction Function:    //   represents the set of characters found in s    ...}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reading-13-Abstraction-Functions-amp-Rep-Invariants&quot;&gt;&lt;a href=&quot;#Reading-13-Abstraction-Functions-amp-Rep-Invariants&quot; class=&quot;headerlink&quot; title=&quot;Reading 13:Abstraction Functions &amp;amp; Rep Invariants&quot;&gt;&lt;/a&gt;Reading 13:Abstraction Functions &amp;amp; Rep Invariants&lt;/h1&gt;&lt;p&gt;关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。&lt;br&gt;&lt;a href=&quot;http://web.mit.edu/6.031/www/sp17/classes/13-abstraction-functions-rep-invariants/#reading_13_abstraction_functions_rep_invariants&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reading 13:Abstraction Functions &amp;amp; Rep Invariants&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MIT" scheme="http://libchan.github.io/categories/MIT/"/>
    
    
      <category term="MIT讲义" scheme="http://libchan.github.io/tags/MIT%E8%AE%B2%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>MIT-6.031-07</title>
    <link href="http://libchan.github.io/2018/03/20/MIT6.031%2007/"/>
    <id>http://libchan.github.io/2018/03/20/MIT6.031 07/</id>
    <published>2018-03-20T09:33:10.888Z</published>
    <updated>2018-03-28T02:29:32.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reading-7-Designing-Specifications"><a href="#Reading-7-Designing-Specifications" class="headerlink" title="Reading 7:Designing Specifications"></a>Reading 7:Designing Specifications</h1><p>关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。<br><a href="http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/" target="_blank" rel="noopener">MIT-6.031-07 Reading 7 : Designing Specifications</a><br><a id="more"></a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本文主要从不同的specs实例对比中，介绍如何设计specs。</p><ol><li>确定性(deterministic)：规格是否定义明确？例如一个输入对应一个输出，还是可以有多种可能。</li><li>说明性()：规格是否说明“到位”？例如是否说明了如何输入，或者对输出结果的要求。</li><li>强度：是否有足够的数据集支撑？例如一个合理的小数集，或者大集合（显然两者起到不同的作用）。   </li></ol><p>上述三个维度有时不可兼得，则我们根据实际权衡，折中达到最优。</p><h2 id="Deterministic-VS-underdetermined-specs"><a href="#Deterministic-VS-underdetermined-specs" class="headerlink" title="Deterministic VS underdetermined specs"></a>Deterministic VS underdetermined specs</h2><pre><code>static int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}                   static int findLast(int[] arr, int val) {    for (int i = arr.length - 1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}</code></pre><p>上面是两个方法,First和Last只是为了区分它们的实现方式。在实际代码中，它们都是<code>find</code>方法。<br>再来看一下<code>find</code>的规格(specification):</p><pre><code>static int findExactlyOne(int[] arr, int val)requires: val occurs exactly once in arreffects:  returns index i such that arr[i] = val </code></pre><p><strong>这个规格<code>findExactlyOne</code>是确定(deterministic)的</strong>：即当输入满足前置条件时，<code>findFirst</code>和<code>findLast</code>方法都可以正确输出，即达成后置条件。</p><p>这里，还有另一个规格<code>findOneOrMore,AnyIndex</code>：</p><pre><code>static int findOneOrMore,AnyIndex(int[] arr, int val)requires: val occurs in arreffects:  returns index i such that arr[i] = val</code></pre><p>它不同于<code>findExactlyOne</code>的是，前置条件变成了val在arr中出现即可，这样弱化了前置条件，导致这个规格是不确定的。若val多次出现，则effects并没有说明返回的index是哪一个，<strong>它是不确定的</strong>。</p><p>注意，此处的<strong>不确定</strong>并不是传统意义的。费确定性代码指的是，给它相同的输入，可能会有不同的输出。<br>为了避免混淆，我们把这种不确定性称为<strong> underdetermined</strong>。</p><h2 id="Declarative-VS-operational-specs"><a href="#Declarative-VS-operational-specs" class="headerlink" title="Declarative VS operational specs"></a>Declarative VS operational specs</h2><p>大致可以分成两种：<code>Declarative spec</code>和<code>Operational spec</code>。<br>声明性的<code>(Declarative spec)</code>：不会描述细节和中间过程。反而注重描述输出结果的属性，与初始输入的关系。<br>操作性的<code>(Operational spec)</code>：描述了方法执行的步骤，细节等，例如伪代码。</p><p><strong> 对于spec，我们更青睐<code>Declarative spec</code> ,因为它简短，易于理解，且更重要的是，它不会暴露具体实现的细节给客户</strong>。</p><p>但是，有时程序员会在spec里写操作性的实现细节利于维护者维护。注意，这不是一个好习惯！这可以在方法内部进行说明，但一定不要让它出现在spec里。</p><p>举个例子吧：</p><pre><code>static String join(String delimiter, String[] elements)effects: append together the strings in elements, but at each step,         if there are more elements left, insert delimiter</code></pre><p>这是一个操作性的(operational)spec。<br>修改它，让它变得declarative，可以这样：</p><pre><code>effects: returns concatenation of elements in order,          with delimiter inserted between each pair of adjacent elements</code></pre><p>更改之后，仅仅说明了属性，没有暴露具体实现。</p><h2 id="Stronger-VS-weaker-specs"><a href="#Stronger-VS-weaker-specs" class="headerlink" title="Stronger VS weaker specs"></a>Stronger VS weaker specs</h2><p>现在我们来考虑这种情况：假设你想要改变一个方法，无视方法的具体实现和spec本身。现在已经有客户采用已有的spec了。是新写一个spec呢？还是用原来的就可以？<br>以上得出，我们需要一个标准来判断两个spec的强弱。S2强于S1，则：</p><ul><li>S2的前置条件弱于S1</li><li>S2的后置条件强于S1</li></ul><blockquote><p>简言之，想要加强一个spec，<strong>弱化前置，强化后置</strong>。</p></blockquote><p>为什么要强化spec？取代原有spec。<br>发现了没，这种“强化升级”，其实也提升了用户体验。减少对用户的需求，却增加了“回报”，让用户放心。</p><p>来，再看看我们之前提到的specs：</p><pre><code>static int findExactlyOne(int[] a, int val)requires: val occurs exactly once in aeffects:  returns index i such that a[i] = val</code></pre><p>弱化前置条件：</p><pre><code>static int findOneOrMore,AnyIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns index i such that a[i] = val</code></pre><p>强化后置条件：</p><pre><code>static int findOneOrMore,FirstIndex(int[] a, int val)requires: val occurs at least once in aeffects:  returns lowest index i such that a[i] = val</code></pre><p>再强化后置条件：</p><pre><code>static int findCanBeMissing(int[] a, int val)requires: nothingeffects:  returns index i such that a[i] = val,or -1 if no such i</code></pre><h2 id="Diagramming-specification"><a href="#Diagramming-specification" class="headerlink" title="Diagramming specification"></a>Diagramming specification</h2><p>我们可以利用图形表示spec，往往更清晰更直观。</p><ul><li>假设Java世界是一个无限空间，我们用一个点代表一个方法，就像这样：<br><img src="https://i.imgur.com/NLsYCzi.jpg" alt=""></li></ul><ul><li><p>spec是有一个合理范围的，对于能实现该spec的方法，我们把它放在范围内，反之则在范围外。<br><code>findFirst</code>和<code>findLast</code>都满足<code>findOneOrMore,AnyIndex</code>，所以在范围内：<br><img src="https://i.imgur.com/8caEGzH.jpg" alt=""></p></li><li><p>再后来我们做了什么事情呢？我们强化了<code>findOneOrMore,AnyIndex</code>，问题来了，怎么表示？<br>1.强化后置：<br>这意味着程序员需要对输出更严格，这导致有的方法之前满足<code>findOneOrMore,AnyIndex</code>(S1)，但现在不满足<code>findOneOrMore,FirstIndex</code>(S2)，那它在S2外，S1里。<br>2.弱化前置：<br>这意味着要处理更多的输入情况。<br>下图中，S2强于S1，<code>findLast</code>在S2范围外，<code>findFirst</code>满足S2，在范围内。<br><img src="https://i.imgur.com/9qoCpZX.jpg" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reading-7-Designing-Specifications&quot;&gt;&lt;a href=&quot;#Reading-7-Designing-Specifications&quot; class=&quot;headerlink&quot; title=&quot;Reading 7:Designing Specifications&quot;&gt;&lt;/a&gt;Reading 7:Designing Specifications&lt;/h1&gt;&lt;p&gt;关于MIT6.031课程的理解翻译工作，略粗糙，欢迎指正。&lt;br&gt;&lt;a href=&quot;http://web.mit.edu/6.031/www/sp17/classes/07-designing-specs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MIT-6.031-07 Reading 7 : Designing Specifications&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MIT" scheme="http://libchan.github.io/categories/MIT/"/>
    
    
      <category term="MIT讲义" scheme="http://libchan.github.io/tags/MIT%E8%AE%B2%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>Maven初步学习</title>
    <link href="http://libchan.github.io/2018/03/11/Maven/"/>
    <id>http://libchan.github.io/2018/03/11/Maven/</id>
    <published>2018-03-11T09:57:42.384Z</published>
    <updated>2018-03-28T02:49:26.838Z</updated>
    
    <content type="html"><![CDATA[<p>初次了解软件构造和maven，仅记录学习maven的过程。<br>本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。<br><a id="more"></a></p><p><strong>1. Maven？</strong></p><p>Maven主要服务于基于Java平台的项目构建，项目信息管理。通俗一点说，Maven不仅是一个构建工具，它是一个<strong>自动化的构建工具</strong>。在软件开发中，其实是有专人负责去构建的(构建是一个过程，包含编译，测试，打包，部署等)，但Maven所做的是把构建的一系列工作<strong>像流水线一样自动完成</strong>。</p><p><strong>2.Maven使用入门</strong></p><ul><li><strong>POM.xml</strong><br>POM(Project Object Model,项目对象模型)，顾名思义，它<strong>定义了项目的基本信息，描述项目如何构建等</strong>。举一个简单的例子： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;Hello-world&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>可以发现代码中定义了groupId,artifactId,version：<br>groupId一般是组织或者公司相关<br>artifactId是唯一的，如上面的例子中是Hello-world<br>version指定版本，SNAPSHOT意为快照，表示当前版本还在开发中，不稳定。</p><blockquote><p><strong>POM.xml可以说是整个Maven项目的核心，我们只需要修改POM.xml即可以达到不同的构建目标，声明依赖关系等。</strong></p></blockquote><ul><li><p><strong>Maven的文件夹默认格式</strong><br>Maven工程是自动化的，所以我们需要<strong>按照约定创建目录</strong>，这样Maven才能在自动化的构建过程中找到源文件，通常约定的结构是这样的：<br><strong><br>|—src                源码<br>|—|—main            存放主程序<br>|—|—|—java        存放Java源文件<br>|—|—|—resources    存放框架或其他工具的配置文件<br>|—|—test            存放测试程序<br>|—|—|—java        存放Java测试的源文件<br>|—|—|—resources    存放测试的配置文件<br>|—POM.xml                Maven工程的核心配置文件</strong></p><p>  手工生成上述目录可以说是很麻烦了，Maven解决了这个问题，提供<strong>Archetype</strong>帮助我们快速勾勒出项目骨架。<br>  Maven3环境下，执行：<br>  mvn archetype:generate<br>  然后会看到很多Archetype可供我们选择，这帮助我们快速构建项目骨架，节省了很多时间。<br>  Eclipse下开发Maven工程：会自动生成上述文件目录，我们只需要按约定放好源文件即可。</p></li></ul><ul><li><p><strong>Maven的构建过程概述</strong></p><p>  我们先看几个主要的Maven命令：<br>  mvn clean compile     //编译<br>  mvn clean test        //测试<br>  mvn clean package    //打包<br>  mvn clean install    //安装项目输出的jar包到本地仓库中</p><p>  先解释一下命令的含义，clean告诉Maven清理输出目录target/(默认情况下，Maven构建的所有输出都在该目录中)，compile告诉Maven编译项目主代码，项目主代码将会编译输出到target/classes目录下。<br>  上述命令其实是对应了Maven的插件以及插件目标，clean是clean插件的目标，test是test插件    的目标。</p><p>  <strong>编译—-&gt;测试—-&gt;打包—-&gt;安装</strong><br>  执行test之前会执行compile，同样执行package之前会执行test。</p></li></ul><p><strong>3.Maven坐标和依赖</strong>  </p><p>坐标这个概念始于平面几何，它可以用来唯一的标识一个元素。<br>《Maven实战中》里，很生动的将其描述为：</p><blockquote><p>Maven给Java类库(例如jar文件)世界引入了经纬，让他们变得有秩序，于是我们可以借助它来有序的管理依赖，轻松的解决那些繁琐的依赖问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初次了解软件构造和maven，仅记录学习maven的过程。&lt;br&gt;本文不包含Maven的安装，环境配置，项目创建等内容，主要记录Maven的特点和概念。&lt;br&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://libchan.github.io/categories/Tool/"/>
    
    
      <category term="Maven" scheme="http://libchan.github.io/tags/Maven/"/>
    
  </entry>
  
</feed>
